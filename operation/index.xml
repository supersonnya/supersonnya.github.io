<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Portfolio on Sonnya</title>
    <link>https://supersonnya.github.io/operation/</link>
    <description>Recent content in Portfolio on Sonnya</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 12 May 2019 12:14:34 +0600</lastBuildDate><atom:link href="https://supersonnya.github.io/operation/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Windows WSL</title>
      <link>https://supersonnya.github.io/operation/windows/windows-wsl/</link>
      <pubDate>Tue, 03 Jan 2023 17:27:07 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/windows/windows-wsl/</guid>
      <description>WSL磁盘迁移 ## 查看wsl状态为Stopped wsl -l -v ## 导出系统镜像 wsl --export Ubuntu V:\ubuntu.tar ## 注销linux系统 wsl --unregister Ubuntu22 ## 查看系统状态，确认是否注销成功 wsl -l -v ## 导入系统 wsl --import &amp;lt;导入后系统名称&amp;gt; &amp;lt;导入后系统盘路径&amp;gt; &amp;lt;系统包路径&amp;gt; --version 2 wsl --import Ubuntu22 V:\ V:\ubuntu.tar --version 2 ## 修改默认登录用户 ### Ubuntu-22.04=ubuntu2204.exe ubuntu22.exe config --default-user ubuntu22 </description>
    </item>
    
    <item>
      <title>Database Redis</title>
      <link>https://supersonnya.github.io/operation/database/redis/database-redis/</link>
      <pubDate>Fri, 09 Dec 2022 16:43:38 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/redis/database-redis/</guid>
      <description>NoSQL数据库 Web发展历史 Web1.0：以门户网站为代表，主要以用户阅读、浏览为主，没有太大性能问题。 Web2.0：用户参与，网站和数据库压力越来越大。 数据库性能瓶颈：单机数据库的性能有限，需要使用Redis作为缓存数据块，解决高并发问题缓解数据库的压力。 NoSQL数据库 非关系型数据库或Not Only SQL，不保证ACID特性。 特点：非关系型；没有模式，可存储结构化、非结构化或半结构化数据；速度快；支持海量数据存储。 应用场景：高并发读写、海量数据读写、高可扩展、速度快。 不适用场景：事务支持、结构化查询。 NoSQL数据库：memcache、Redis、mongoDB。 NewSQL：基于NoSQL又可支持SQL操作，例如HBase。 Redis介绍 基本介绍 开源的、使用ANSI、C语言编写的key-value数据库。 与Memcache类似，数据缓存在计算机内存中。 应用场景 取出最新N个数据。 排行榜应用，取出TOP N操作。 需要精准设定过期时间的应用，例如短信验证码。 计数器应用。 获取某段时间所有数据去重值。 实时系统，反垃圾系统，用于存储一些规则。 缓存，数据之间存放在内存中。 特点 高效性：高速读写。 原子性：所有操作都是原子性的。 支持多种数据结构：字符串、列表、集合、哈希、有序集合。 稳定性：持久化、主从复制集群。 其他特性：过期时间、事务、消息订阅。 Redis安装 ## 获取安装包redis.tar.gz ## 解压安装包 tar -zxvf redis.tar.gz ## 安装C程序运行环境 yum install gcc-c++ -y ## 安装新版本tcl，控制Linux中命令的执行流程 yum install tcl -y ## 编译redis make make test &amp;amp;&amp;amp; make install ## 修改redis配置文件 mkdir -p ./redis-x.x.x/log mkdir -p ./redis-x.x.x/data vi redis.</description>
    </item>
    
    <item>
      <title>JumpServer</title>
      <link>https://supersonnya.github.io/operation/devops/devops-jumpserver/</link>
      <pubDate>Fri, 11 Nov 2022 14:48:11 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/devops/devops-jumpserver/</guid>
      <description>堡垒机 通过堡垒机控制IT系统运维风险。 统一入口、批量管理、自动运维、安全运营。 身份鉴别、账号管理、权限控制、安全审计。 审计只是事后行为，无法防止问题发生。 事先严格监控，从源头解决服务器误操作问题。 堡垒机能够创建系统账号，但账号只是区分角色功能，无法确认账号的执行人。 跳板机的缺陷，企业需要更新、更好、更安全的技术理念管理服务器的运维操作，需要一种能够满足角色管理、角色授权、信息资源访问控制、操作记录和审计、系统变更维护控制等需求，生成服务器资产统计报表功能。 核心作用 系统运维和安全审计管理；过滤和拦截非法请求访问、恶意攻击，拒绝不合法命令，进行审计监控、报警和责任追踪；报警、记录、分析、处理。 解决运维权限混乱、操作无审计的问题。 核心功能 单点登录；账号管理；身份认证；资源授权；访问控制；操作审计。 应用场景 多用户使用同一个账号； 一个用户使用多个账号； 缺少统一的权限管理平台，无法实现高粒度的命令权限控制； 对于传统的网络设备无法对运维人员的远程连接命令进行加密、审计。 企业角度 通过更加细致的粒度对企业IT资产设备进行管理，保证企业的IT设备资产安全、可靠运行，降低人为操作的风险，避免风险性，保证企业的资源资金安全。 管理角度 一次登录即可快捷访问多台设备，提升工作效率，对服务器最大化的安全性操作。 跳板机 跳板机：一台服务器，必须先连接跳板机才能去操控内网中的服务器。
仅实现了服务器安全登录，没有实现对运维人员的行为操控和审计，使用过程中可能出现误操作，无法定位实施人。 集中式对服务器进行管理。 </description>
    </item>
    
    <item>
      <title>EMC CX存储</title>
      <link>https://supersonnya.github.io/operation/storage/storage-emc_cx/</link>
      <pubDate>Wed, 09 Nov 2022 16:54:02 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/storage/storage-emc_cx/</guid>
      <description>PN 005048829=005049541=005049412PWR=005048797 005049031=005048950 005048632=005048807 005048808=005048751 注册HBA卡 在Hosts标签页中打开右侧Storage System Connectivity Status，选中需要注册的HBA卡，点击Edit，选择归属主机，Initiator Information选择CLARiiON Open，Failover Mode选择Active-Active mode(ALUA)-failovermode4，点击确定。 删除不需要的HBA配置项。 分配存储组：选择Storage下的Storage Groups，选中需要分配的主机组，点击Connect Hosts，选中需要加入的主机，点击应用。 重启 出现以下情况的时候，可能需要重启Navisphere Management Server 一些物理部件上出现错误图标(&amp;ldquo;F&amp;quot;标记)，但Navisphere CLI未报告错误 主机上出现&amp;quot;U&amp;quot;标记，即使重启主机也无效 Navisphere UI出现错误信息，但Navisphere CLI未报告或显示不一样的错误信息 解除管理的SP仍拥有某些LUN Navisphere UI显示错误信息，但当点击的时候报告阵列工作正常 Navisphere Manager未能识别新添加的DAE 重启Navisphere Management Server (CIMOM)可能会解决上述问题，步骤如下： 重启步骤 需在两台SP上分别执行。 http: //&amp;lt;IP_address_of_SP&amp;gt;/setup 进入Navisphere User Interface (UI) 点击Restart Management Server 点击Yes并Submit </description>
    </item>
    
    <item>
      <title>Zabbix</title>
      <link>https://supersonnya.github.io/operation/devops/devops-zabbix/</link>
      <pubDate>Tue, 08 Nov 2022 23:28:41 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/devops/devops-zabbix/</guid>
      <description>监控分类 硬件监控 通过远程控制卡：Dell的IDRAC，HP的ILO和IBM的IMM等； 使用IPMI完成物理设备的监控工作，通常必须监控温度、硬盘故障等； 路由器、交换机（端口、光衰、日志）、打印机、系统等。 系统监控 CPU，内存、硬盘使用率，硬盘IO，系统负载，进程数。 服务监控 apache、nginx、php-fpm、mysql、memcache、redis、tomcat、JVM、TCP连接数等。 性能监控 网站性能、服务器性能、数据库性能、存储性能。 日志监控 系统日志、应用访问日志、错误日志、服务影讯日志，可使用ELK进行日志监控。 安全监控 图形化展示不同攻击类型统计； 监控登录用户数，passwd文件，本地文件的改动。 网络监控 端口、WEB|URL、DB、ping包、IDC带宽网络流量、网络流入流出速率、网络入出流量、网络使用率、SMTP、POP3。 完善的监控系统的特点 基本要求 监控系统能够自定义监控的内容，自己通过脚本采集所需的数据； 数据需要存入数据库，以便之后对数据进行分析计算； 监控系统可以简易、快速地部署到服务器； 数据可视化直观清晰。 监控工具 Cobbler、SALTSTACK、Kubernetes、Zabbix、elastic、Jenkins。 异常告警通知 可以定义复杂度告警逻辑，做到监控项之间的关联告警，例如程序之间的依赖检测，而不是只单独检测某一个指标； 告警可以确认响应，让运维组内的人知道已经有人在处理告警； 告警方式可以自定义，如短信、邮件； 告警内容可以自定义，能够写入一些简单的分析，便于运维人员直观了解数据； 告警后可以预处理一些任务，例如自我修复、重启、采集数据等。 协同工作 监控系统有强大的API，提供给外部调用； 监控数据有开放性和主流的数据结构，便于解析； 监控可视化可使用简易的插件，而非复杂的JS文件。 Zabbix简介 Zabbix介绍 Zabbix是一种网络监视、管理系统，基于CS架构，可用于监视各种网络服务、服务器和网络机器等的状态。 Zabbix使用各种数据库存储数据，如MySQL、PostgreSQL、SQLite、Oracle、DB2等。Server端基于C，Web管理端基于PHP。 Zabbix可使用多种监控方式：只使用Simple Check不安装客户端；也可基于SMTP或HTTP等协议定制监控。 Zabbix自带的Item满足普通监控需求，也可自定义Item，自动生成报表，同时提供外部API。 Zabbix优势 支持自定义监控脚本，提供需要输出的值即可； 存储的数据库表结构逻辑清晰； 通过模板可以便捷部署一组监控项； 每个监控项都可看到历史记录，且界面友好； 强大的触发器定义规则，可定义复杂的告警逻辑； 支持短信、邮件、微信等告警方式，提供告警确认机制； 触发告警后，可远程执行系统命令； 有原生的PHP绘图模块。 Zabbix术语 zabbix server：服务端，收集数据，写入数据。 zabbix agent：部署在被监控机器上，是一个进程，与zabbix server进行交互，负责执行命令。 host：监控的实体主机对象。 hosts：实体主机组。 applications：应用。 events：事件。 media：发送通知的通道。 remote command：远程命令。 template：模板。 item：监控项。 trigger：触发器，定义告警逻辑，有正常、异常、未知三个状态。 action：触发器事件出发后，指定的动作。 Zabbix程序组件 zabbix_server：服务器守护进程。 zabbix_agentd：agent守护进程。 zabbix_proxy：代理服务器。 zabbix_database：数据库系统。 zabbix_web：可视化界面。 zabbix_get：命令行工具，测试向agent发起数据采集请求。 zabbix_sender：命令行工具，测试向server发送数据。 zabbix_java_gateway：Java网关。 Zabbix Server安装 ## 查看IP ifconfig eth0 | awk &amp;#39;NR==2{print $2}&amp;#39; ## 关闭防火墙 sed -i &amp;#39;s/SELINUX=enforcing/SELINUX=disabled/&amp;#39; /etc/selinux/config systemctl disable --now firewalld ## 获取zabbix下载源 rpm -Uvh http://mirrors.</description>
    </item>
    
    <item>
      <title>软考网工</title>
      <link>https://supersonnya.github.io/operation/network/network-software_technology_networkengineer/</link>
      <pubDate>Wed, 02 Nov 2022 10:00:10 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/network/network-software_technology_networkengineer/</guid>
      <description>dhcp select rely：广播转单播 option 43: 给AP分配地址的同时，告诉AP AC的地址是多少
基础配置：system-view、sysname、vlan batch、interface vlanif、写IP地址、SVI 高频配置：VLAN、DHCP、ACL/基于时间的ACL、策略路由、NAT、路由（静态/默认/RIP/OSPF） 偏门配置：IPv6、4G、WLAN、IPSec
路由策略和策略路由： 路由策略作用于控制层面，用于路由控制和过滤。策略路由作用于数据层面，用于流量控制。 都可以实现访问控制，都会依赖ACL这类匹配工具。 为避免回路，交换机上需配置STP协议进行破环。 生成BGP路由的方式： 手动聚合：优先级最高。 自动聚合： network：逐条将IP路由表中已存在的路由引入BGP路由表，内部路由，优先级高。 import：根据运行的路由协议将路由引入到BGP路由表，可以引入直连和静态路由，优先级最低。 IPSec VPN应用场景： Site-to-Site：又称网关到网关，多个异地机构利用运营商忘了建立IPSec隧道，将各自内部网络联系起来。 End-to-End：又称远程访问，即两个PC之间的通信由IPSec完成，通常以远程访问的方式建立临时的连接进行，如PPTP VPN、SSL-VPN等建立临时连接。 End-to-Site：两个PC之间的通信由网关和异地PC之间的IPSec会话完成。 洪水攻击属于DOS或DDOS，拒绝服务类。 私接路由并开启DNCH功能，会获取不正常的IP。启用DHCP Snooping功能，避免非法DHCP服务器。 MTBF的单位是小时。 关键链路冗余：接口备份、接口监控组、VRRP、双机热备技术。 AC为无线控制器，部署方式： 直连部署：业务流经过AC。可能存在需要AC转发大量的业务流量，对AC的吞吐量和数据处理能力要求较高，AC容易成为整个无线网络带宽的瓶颈。 旁路部署：业务流不经过AC。 NAT通常部署在路由器上，实现隐藏内部网络。 无线网络认证方式： Portal：也称Web，以网页形式为用户提供身份认证和个性化服务。 PPPOE 802.1x：通过认证可以访问局域网中的资源，否则无法访问，相当于物理断开。 通常建议的无线网络优化策略：降低AP发射功率、调整/优化使用的信道。 AP的供电方式有：POE供电和DC电源适配器供电。POE供电可同时提供电功率和传输数据，两种供电方式，使用空闲脚供电和使用数据脚供电，使用空闲脚供电时，双绞线的4、5为正极，7、8为负极为PD设备供电。 防火墙工作模式： 透明模式：相当于一台交换机，接口不配置IP地址。 路由模式：相当于一台路由器，接口配置IP地址。 混合模式 常见的网关冗余技术：VRRP、堆叠/集群，堆叠技术可以统一控制层面，简化网络管理。 交换机连接方式有级联和堆叠，堆叠方式可以共享使用交换机背板带宽，级联方式可以使用双绞线将交换机连接在一起。 光功率计：测量光衰。 光时域反射计：测量光衰衰减、接头损耗、光纤故障点定位。 为实现链路冗余，需要在防火墙和核心交换机上配置链路聚合。 两台出口防火墙之间的线缆是心跳线，防火墙配置的功能有NAT、IPSec、安全过滤。 APT攻击，主要从技术和管理上进行防范： 技术上：部署沙箱、态势感知等系统，联动防火墙、入侵检测、交换机等设备进行综合分析。 管理上： 制定网络安全管理制度； 明确网络安全主体责任； 细化网络安全工作职责，责任到人； 合理分配人员权限、最小权限和加强审计； 加强网络安全意识和技能培训； 强化网络安全执行监督。 攻击者隐藏自己身份和攻击痕迹的方式：使用代理/跳板/肉鸡，清除攻击日志、使用隐藏信息。 字典/暴力破解/猜密码，限制登录次数，设置强密码，定期修改密码。 不影响业务网络和业务服务器，建议采用的备份架构是Sever-Free。 数据备份网络架构： LAN-BASED拓扑：数据流经备份服务器和介质服务器备份至数据备份存储介质。 LAN-FREE拓扑：数据备份在SAN存储。 Server-Free：备份数据流直接通过介质服务器经由独立的SAN网络进行传输。 优点：对业务主机几乎无影响；对现有业务网络几乎无影响；备份性能好，依赖SAN网络。 缺点：对网络的投资较大；对设备要求高。 为最大程度节省存储空间，建议采用增量备份策略。 交换机和主机速率不一致：网线故障、网卡驱动不兼容、主机使用低速率网卡。 AAA分别指：认证、授权、计费。PPPOE认证依赖BRAS设备，通常应用于校园网/运营商家庭宽带场景。CHAP认证采用三次握手，底层依赖HASH算法。 VRRP实现容错和增强的路由选择功能，交换机之间的连线为心跳线，用于传递VRRP报文。 核心交换机和防火墙互通的默认路由，目标地址应为0.</description>
    </item>
    
    <item>
      <title>Linux Learnplans</title>
      <link>https://supersonnya.github.io/operation/linux/linux-learnplans/</link>
      <pubDate>Fri, 28 Oct 2022 10:01:22 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-learnplans/</guid>
      <description>组态管理工具 (Puppet, SaltStack, Chef, Ansible) 部署：saltstack, puppet, ansible
监控：cati, zabbix, nigos
熟悉Linux等操作系统的安装、配置、更新、维护操作，掌握系统命令，调试方法,熟练使用grep/sed/awk;
熟悉Jenkins，gitlab，svn，nginx，tomcat, zookeeper等软件;
熟悉Mysgl，mongodb，redis等不同类型数据库，精通 SQL 语句;
精通shell或者python语言，对自动化运维有经验者优先;
熟悉docker\kubernetes等微服务项目发布相关技术;
熟悉Hyper-V，VMWare等虚拟化软件的使用，能按不同的需求搭建不同的虚拟化环境;
熟悉mysgl，postgres，es，k8s等集群搭建，了解服务治理、云原生等概念;
MQ类,Keeplived,fastdfs
熟悉阿里云或者腾讯云的产品，孰悉云服务管理及维护;
主流网络安全产品，如WAF、防火墙、日志审计、IPS等安全产品;
服务器、网络设备的运行特点，能够对常见故障进行排查;
计算机网络设备及各类网络协议的概念和作用，了解常用公有云计算、存储、网络、安全类产品构成;
常用巡检命令 uname -a # 查看内核/操作系统/CPU信息 head -n 1 /etc/issue # 查看操作系统版本 cat /proc/cpuinfo # 查看CPU信息 hostname # 查看计算机名 lspci -tv # 列出所有PCI设备 lsusb -tv # 列出所有USB设备 lsmod # 列出加载的内核模块 env # 查看环境变量 free -m # 查看内存使用量和交换区使用量 df -h # 查看各分区使用情况 du -sh &amp;lt; 目录名&amp;gt; # 查看指定目录的大小 grep MemTotal /proc/meminfo # 查看内存总量 grep MemFree /proc/meminfo # 查看空闲内存量 uptime # 查看系统运行时间、用户数、负载 cat /proc/loadavg # 查看系统负载 mount | column -t # 查看挂接的分区状态 fdisk -l # 查看所有分区 swapon -s # 查看所有交换分区 hdparm -i /dev/hda # 查看磁盘参数(仅适用于IDE设备) dmesg | grep IDE # 查看启动时IDE设备检测状况 ifconfig # 查看所有网络接口的属性 iptables -L # 查看防火墙设置 route -n # 查看路由表 netstat -lntp # 查看所有监听端口 netstat -antp # 查看所有已经建立的连接 netstat -s # 查看网络统计信息 ps -ef # 查看所有进程 top # 实时显示进程状态 w # 查看活动用户 id &amp;lt; 用户名&amp;gt; # 查看指定用户信息 last # 查看用户登录日志 cut -d: -f1 /etc/passwd # 查看系统所有用户 cut -d: -f1 /etc/group # 查看系统所 crontab -l # 查看所有用户的定时任务 系统服务管理 service --status-all # 系统所有的后台服务进程 service sshd status # 服务进程状态 service sshd stop/start/restart ## 配置开机自启动 chkconfig httpd on/off 网络管理 ## 主机名配置 hostname hostname new_name # 重启后失效 vi /etc/sysconfig/network # 永久生效 ## IP配置 setup # 交互修改界面，需要安装setuptool软件 vi /etc/sysconfig/network-scripts/ifcfg-eth0 # 永久生效 ifconfig eth0 ip_addr # 重启后失效 ## 域名映射 vi /etc/hosts ## 网络端口监听 # netstat: 列出系统上所有的网络socket连接情况 ## -a: 所有选项，默认不显示LISTEN相关 -t -u ## -n: 只显示IP，禁用域名反向解析 ## -l: 仅显示在Listen的服务状态 ## -p: 显示建立相关链接的进程信息 ## -ep: 同时查看进程名和用户名 netstat -nlpt # 获取进程名、进程号及用户ID netstat -tnl # 处于监听状态的TCP端口和连接 crontab ## 设置周期性执行指定的指令或脚本 ## 安装 yum install crontabs ## 服务操作 service crond start/stop/restart/status service crond reload # 重新载入配置 chkconfig crond --list # 是否已设置开机启动 chkconfig crond on ## 命令格式 ### file: 命令文件的名字 ### -u: 设定某个用户的crontab服务 ### -e: 编辑某个用户的crontab文件内容，不指定默认当前用户 ### -l: 显示某个用户的crontab文件内容，不指定默认当前用户 ### -r: 删除某个用户的crontab文件，，不指定默认当前用户 crontab [-u user] file crontab [-u user] [-e | -l | -r] ## 配置说明 ## * * * * * command ## 分 时 日 月 周 命令 ## 1~59分，每分钟用*或*/1表示 ## 0~23时 ## 1~31日 ## 1~12月 ## 0~6，0表示星期天 ## 实例 ### 每分钟执行一次date */1 * * * * date &amp;gt;&amp;gt; /root/date.</description>
    </item>
    
    <item>
      <title>Windows Ftpserver</title>
      <link>https://supersonnya.github.io/operation/windows/windows-ftpserver/</link>
      <pubDate>Wed, 26 Oct 2022 10:50:07 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/windows/windows-ftpserver/</guid>
      <description>搭建步骤 开启FTP功能 Win+R，输入optionalfeatures，选择Internet Information Services下面的FTP服务器、Web管理工具、万维网服务。 允许FTP通过防火墙 搜索允许应用或功能通过Windows Defender防火墙，打开在运行列表中勾选FTP服务器。 点击允许其他应用，添加C:\Windows\System32\svchost.exe到允许列表。 创建FTP服务器 搜索并打开IIS管理，在网站右键新建FTP站点，填写网站名称、路径、IP等信息，选择无SSL。 设置账号权限：身份验证为匿名+基本，授权给指定用户，权限为D+W。 连接到创建的服务器 点击右侧的基本设置，点击连接为，选择特定用户，输入管理员的用户名和密码。 点击FTP身份验证，基本身份验证和匿名身份验证均为已启用。 添加匿名用户权限 点击FTP授权规则，点击右键添加允许规则，选择所有匿名用户并分配D权限。 Q&amp;amp;A 密钥集不存在 错误代码：0x80090016 添加Windows功能时默认勾选IIS服务没有万维网服务，勾选万维网服务菜单下的安全性下的内容。 匿名用户登陆后切换登录用户 文件资源管理器页面，鼠标右键点击登录，输入其他用户名口令登录。 Windows访问FTP的方法 FTP工具 打开cmd，输入ftp ftpserver_ip进行连接。 Windows资源管理器 打开文件资源管理器，地址栏输入ftp://ftpserver_ip。 浏览器 打开浏览器，地址栏输入ftp://ftpserver_ip。 </description>
    </item>
    
    <item>
      <title>Network Huawei_ensp</title>
      <link>https://supersonnya.github.io/operation/network/network-huawei_ensp/</link>
      <pubDate>Mon, 24 Oct 2022 17:40:21 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/network/network-huawei_ensp/</guid>
      <description>一、安装 先安装步骤1.依赖组件中的在三个组件，其中VBOX不要安装在中文目录； 安装步骤2.的eNSP主程序； 导入设备包（可选）。 二、使用 参考eNSP基础操作视频； 防火墙默认用户名、密码：admin/Admin@123。 三、排障 AR设备40，按提示排障失败的，可以尝试右击开始菜单，PowerShell(管理员身份)，运行bcdedit /set hypervisorlaunchtype off重启电脑再尝试； AR设备无限#号后超时，检查本机防火墙，关闭防火墙或放行eNSP开头的所有程序； 防火墙启动超时，检查CPU虚拟化是否启用；如果仍未解决，可以尝试加载设备包中的1.2版本防火墙设备包。 </description>
    </item>
    
    <item>
      <title>Linux Grep</title>
      <link>https://supersonnya.github.io/operation/linux/linux-grep/</link>
      <pubDate>Fri, 14 Oct 2022 16:30:38 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-grep/</guid>
      <description>语法 grep用于查找文件里符合条件的字符串。grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据。 文本搜索工具，根据用户指定的模式对目标文本逐行进行匹配检查，打印匹配到的行。 模式：由正则表达式的元字符及文本字符所编写出的过滤条件。 grep [-abcEFGhHilLnqrsvVwxy][-A&amp;lt;显示行数&amp;gt;][-B&amp;lt;显示列数&amp;gt;][-C&amp;lt;显示列数&amp;gt;][-d&amp;lt;进行动作&amp;gt;][-e&amp;lt;范本样式&amp;gt;][-f&amp;lt;范本文件&amp;gt;][--help][范本样式][文件或目录...]。 grep需要使用参数- E支持正则表达式，egrep不推荐使用，使用grep -E代替。 grep不加参数，需要在特殊字符前加\，识别为正则表达式。 参数说明 `-a 或 &amp;ndash;text** : 不要忽略二进制的数据。 `-A&amp;lt;显示行数&amp;gt; 或 &amp;ndash;after-context=&amp;lt;显示行数&amp;gt;** : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。 `-b 或 &amp;ndash;byte-offset** : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。 `-B&amp;lt;显示行数&amp;gt; 或 &amp;ndash;before-context=&amp;lt;显示行数&amp;gt;** : 除了显示符合样式的那一行之外，并显示该行之前的内容。 `-c 或 &amp;ndash;count** : 计算符合样式的行数。 -C&amp;lt;显示行数&amp;gt; 或 --context=&amp;lt;显示行数&amp;gt;或-&amp;lt;显示行数&amp;gt;：除了显示符合样式的那一行之外，并显。该行之前后的内容。 -d &amp;lt;动作&amp;gt; 或 --directories=&amp;lt;动作&amp;gt;：当指定要查找的是目录而非文件时，必须使用这项参数。否则grep指令将回报信息并停止动作。 -e&amp;lt;范本样式&amp;gt; 或 --regexp=&amp;lt;范本样式&amp;gt;：指定字符串做为查找文件内容的样式。 -E 或 --extended-regexp：将样式为延伸的正则表达式来使用。 -f&amp;lt;规则文件&amp;gt; 或 --file=&amp;lt;规则文件&amp;gt;：指定规则文件，其内容含有一个或多个规则样式，让gre。查找符合规则条件的文件内容，格式为每行一个规则样式。 -F 或 --fixed-regexp：将样式视为固定字符串的列表。 -G 或 --basic-regexp：将样式视为普通的表示法来使用。 -h 或 --no-filename：在显示符合样式的那一行之前，不标示该行所属的文件名称。 -H 或 --with-filename：在显示符合样式的那一行之前，表示该行所属的文件名称。 -i 或 --ignore-case：忽略字符大小写的差别。 -l 或 --file-with-matches：列出文件内容符合指定的样式的文件名称。 -L 或 --files-without-match：列出文件内容不符合指定的样式的文件名称。 -n 或 --line-number：在显示符合样式的那一行之前，标示出该行的列数编号。 -o 或 --only-matching：只显示匹配PATTERN 部分。 -q 或 --quiet或--silent：不显示任何信息。 -r 或 --recursive：此参数的效果和指定&amp;quot;-d recurse&amp;quot;参数相同。 -s 或 --no-messages：不显示错误信息。 -v 或 --invert-match：显示不包含匹配文本的所有行。 -V 或 --version：显示版本信息。 -w 或 --word-regexp：只显示全字符合的列。 -x --line-regexp：只显示全列符合的列。 -y：此参数的效果和指定&amp;quot;-i&amp;quot;参数相同。 实例 在Linux平台，所有的文件结尾都有一个$符号，使用cat -En filename.</description>
    </item>
    
    <item>
      <title>Linux Awk</title>
      <link>https://supersonnya.github.io/operation/linux/linux-awk/</link>
      <pubDate>Fri, 14 Oct 2022 16:29:26 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-awk/</guid>
      <description>语法 awk是一种处理文本文件的语言，是一个强大的文本分析工具。 Linux文本报告生成器——格式化文本，Linux上是gawk。 awk [选项参数] &#39;script&#39; var=value file(s)或awk [选项参数] -f scriptfile var=value file(s)。 默认以空格为分隔符，多个空格也识别为一个空格作为分隔符，$0代表整行，$1代表第一列，$NF表示当前分割后的最后一列，$(NF-1)为倒数第二列，FS指定分隔符，NR代表当前记录数。 awk按行处理文件，一行处理完毕再处理下一行，根据用户指定的分隔符工作，未指定则默认空格。 外层必须单引号，内层双引号，内置变量不得添加双引号，否则识别为文本。 参数 -F -v: 定义或修改内部变量 -f: 从脚本文件读取命令
内置变量
FS: 输入字段分隔符，默认空白字符。 OFS: 输出字段分隔符，默认空白字符。 RS: 指定输入时的换行符。 ORS: 指定输出时的换行符。 NF: 当前行的字段个数。 NR: 当前处理的文本的行号。 FNR: 各文件分别计数的行号。 FILENAME: 当前文件名。 ARGC: 命令行参数个数。 ARGV: 数组，保存命令行传递的所有参数。 选项参数说明 -F fsor--field-separator fs：指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式。 -v var=valueor--asign var=value：赋值一个用户定义变量。 -f scripfileor--file scriptfile：从脚本文件中读取awk命令。 -mf nnn and -mr nnn：对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。 -W compact or --compat, -W traditional or --traditional：在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。 -W copyleft or --copyleft, -W copyright or --copyright：打印简短的版权信息。 -W help or --help, -W usage or --usage：打印全部awk选项和每个选项的简短说明。 -W lint or --lint：打印不能向传统unix平台移植的结构的警告。 -W lint-old or --lint-old：打印关于不能向传统unix平台移植的结构的警告。 -W posix：打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符和=不能代替^和^=；fflush无效。 -W re-interval or --re-inerval：允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。 -W source program-text or --source program-text：使用program-text作为源代码，可与-f命令混用。 -W version or --version：打印bug报告信息的版本。 实例 ## 一次输出多列，逗号输出默认分隔符 awk &amp;#39;{print $1,$2}&amp;#39; filename.</description>
    </item>
    
    <item>
      <title>Linux Sed</title>
      <link>https://supersonnya.github.io/operation/linux/linux-sed/</link>
      <pubDate>Fri, 14 Oct 2022 16:29:22 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-sed/</guid>
      <description>语法 sed命令是利用脚本来处理文本文件，可依照脚本的指令来处理、编辑文本文件。主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。 流编辑器，文本编辑工具，使用单引号。 sed [-hnV][-e&amp;lt;script&amp;gt;][-f&amp;lt;script&amp;gt;] [filename]。 参数说明 -e&amp;lt;script&amp;gt;或--expression=&amp;lt;script&amp;gt;：以指定的script来处理输入的文本文件。 -f&amp;lt;script_file&amp;gt;或--file=&amp;lt;script_file&amp;gt;：以指定的script文件来处理输入的文本文件。 -h或--help：显示帮助。 -i: 直接将修改结果写入文件，不适用该参数时修改的是内存数据。 -n或--quiet或--silent：仅显示script处理后的行。 -r: 支持扩展正则表达式。 -V或--version：显示版本信息。 内置命令字符 a：新增，后面可以接字串，字符串插入在当前行后的新行。 c：取代，后面可以接字串，字串可以取代n1,n2之间的行。 d：删除，后面通常没有内容。 i：插入，后面可以接字串，字符串插入在当前行前的新行。 p：打印，将某个选择的数据印出，通常与参数sed -n一起运行。 s/正则/替换内容/g：取代，通常搭配正则表达式使用。 匹配范围 空地址：全文处理； 单地址：指定文件某一行； pattern：被模式匹配到的每一行； 范围区间：10,20表示十到二十行，10,+5表示从第十行开始向下五行； 步长：1~2表示从一开始步长为2。 实例 ## 输出第2，3行的数据 sed -n &amp;#39;2,3p&amp;#39; filename.txt ## 过滤含有linux的行 sed -n &amp;#39;/linux/p&amp;#39; filename.txt ## 删除包含game的行 sed &amp;#39;/game/d&amp;#39; filename.txt ## 删除第5行之后的行 sed &amp;#39;5,$d&amp;#39; filename.txt ## 所有的My替换为I sed &amp;#39;s/My/I/g&amp;#39; filename.txt ## 多提替换，My替换为I，同时替换数字 sed -e &amp;#39;s/My/I/g&amp;#39; -e &amp;#39;s/888/666/g&amp;#39; filename.txt ## 第二行后插入内容，添加多行信息使用\n换行 sed -i &amp;#39;2a I am good.</description>
    </item>
    
    <item>
      <title>Ansible基础</title>
      <link>https://supersonnya.github.io/operation/devops/devops-ansible/</link>
      <pubDate>Wed, 12 Oct 2022 09:05:24 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/devops/devops-ansible/</guid>
      <description>ansible简介 ansible的特点 部署简单，没有客户端，只需在主控端部署ansible环境，被控端无需安装客户端； 模块化：调用特定的模块，完成特定任务； 默认使用SSH协议对设备进行管理； 主从集中化管理； 配置简单、功能强大、扩展性强； 支持API及自定义模块，可通过Python轻松扩展； 通过playbooks来定制强大的配置、状态管理 对云计算平台、大数据有很好的支持； 具有幂等性：一个操作在一个主机上执行一遍和执行N遍的结果是一样的。 ansible工作机制 ansible在管理节点将ansible模块通过SSH协议推送到被管理端执行，执行完之后自动删除，可以使用SVN等来管理自定义模块及编排。 ansible基于模块工作，本身没有批量部署的能力。真正具有批量部署的是ansible运行的模块，ansible只是提供一种框架。 Ansible： ansible的核心模块； Host Inventory：被管理的主机列表； Playbooks：ansible的执行脚本，批量执行任务； Core Modules：ansible的核心模块； Custom Modules：自定义模块； Connection Plugins：连接插件，用于与被管控主机之间基于SSH建立连接关系 Plugins：其他插件，包括记录日志等。 ansible安装 Ubuntu22安装ansible ## 更新软件包索引, 安装software-properties-common ## software-properties-common用于管理独立的软件存储库 sudo apt update sudo apt install software-properties-common ## 添加ansible PPA sudo apt-add-repository ppa:ansible/ansible ## 更新软件包索引, 安装ansible sudo apt update sudo apt install ansible ansible命令 基本命令 ## 查看ansible的版本 ansible --version ## 查看组下所有主机IP ansible all --list ## ansible的命令参数 ## 语法ansible [-i 主机文件] [-f 批次] [组名] [-m 模块名称] [-a 模块参数] -v	## 详细模式，如果执行成功，输出详细结果 -i	## 指定host文件路径，默认/etc/ansible/hosts -f,-forks=NUM	## NUM默认是整数5，指定fork开启同步进程的个数 -m	## 指定使用的module名称，默认command模块 -a	## 指定模块的参数 -k	## 提示输入SSH密码，而不是使用基于ssh密钥认证 -sudo ## 指定使用sudo获取root权限 -K	## 提示输入sudo密码 -u	## 指定移动端的执行用户 -C	## 测试命令执行会改变什么内容，不会真正的去执行 ansible-doc ## 列出所有模块列表 ansible-doc -l ## 查看指定模块的参数 ansible-doc -s &amp;lt;modulename&amp;gt; ansible的使用 自定义配置连接 ## 配置路径/etc/ansible/hosts ansible_ssh_port ## 指定ssh端口 ansible_ssh_user ## 指定 ssh 用户 ansible_ssh_pass ## 指定 ssh 用户登录是认证密码 ansible_sudo_pass ## 指明 sudo 时候的密码 ssh密钥访问 ssh-keygen ssh-copy-id username@host_ip 测试命令 ansible -m command -a &amp;#34;free -m &amp;#34; webservers ansible -m command -a &amp;#34;useradd sonnya&amp;#34; webservers ansible -m command -a &amp;#34;id sonnya&amp;#34; web-servers ansible高级用法 常用模块 3个远程模块的区别 command：ansible的默认模块，不指定-m参数时，使用command模块；常见的命令都可使用，但命令的执行不是通过shell来执行的，&amp;lt;, &amp;gt;, |, &amp;amp;这些操作不可用，不支持管道，无法批量执行命令； shell模块：使用shell模块时默认通过/bin/sh执行，在终端输入的各种命令都可使用； scripts模块：使用scripts模块可在本地写一个脚本，在远程服务器上执行。 copy模块 实现主控端向目标主机拷贝文件，类似scp。 ansible webservers -m copy -a &amp;quot;src=https://supersonnya.github.io/etc/hosts dest=/root owner=root group=root mode=0777&amp;quot; file模块 给文件设置权限。 ansible webservers -m file -a &amp;quot;path=/etc/hosts mode=0755&amp;quot; stat模块 获取远程文件信息。 ansible webservers -m stat -a &amp;quot;path=/etc/hosts&amp;quot; get_url模块 实现远程主机下载指定的url地址，支持sha256sum文件校验。 ansible webservers -m get_url -a &amp;quot;url=https://xxx dest=/tmp/ mode=0440 force=yes&amp;quot; yum模块 管理软件包。 ansible webservers -m yum -a &amp;quot;name=httpd state=installed&amp;quot; cron模块 远程管理主机crontab配置。 ansible webservers -m cron -a &amp;quot;name=&#39;echo_hello&#39; minute=&#39;*/30&#39; job=&#39;echo hello&#39;&amp;quot; service模块 远程管理主机系统服务。 ansible webservers -m service -a &amp;quot;name=httpd state=restarted&amp;quot; user模块 管理远程主机的用户。 ansible webservers -m user -a &amp;quot;name=sonnya state=present&amp;quot; </description>
    </item>
    
    <item>
      <title>Shell编程基础</title>
      <link>https://supersonnya.github.io/operation/linux/linux-shell_programbasical_three/</link>
      <pubDate>Tue, 13 Sep 2022 20:35:00 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-shell_programbasical_three/</guid>
      <description>基本文本处理 使用echo输出文本 1、显示普通字符串 echo基本语法：echo [options] string…，-n选项表示不输出行尾换行符。 2、显示转义字符 使用-e选项使echo支持转义字符。 ## echo命令的转义字符 \a ## 报警符，相当于ASCII码的BEL字符 \b ## 退格符 \c ## 禁止继续输出文本,包括最后的换行符 \f ## 换页符 \n ## 换行符 \r ## 回车符 \t ## 水平制表符 \v ## 垂直制表符 \\ ## 反斜线 3、显示变量 echo &amp;quot;$name&amp;quot;，有时需要使用花括号将变量名括起来。 如果变量名与不能作为变量名的字符，如-、’、/等连接在一起时，可以不使用花括号。 4、显示命令执行结果 echo可将Shell命令执行结果显示出来，在显示命令执行结果的时候，需使用反引号将命令引用起来。 文本的格式化输出 使用UNIX制表符。 使用fold命令格式化行。 ## options表示选项,file指定要输出的文件名，可以是多个文件，用空格隔开 fold [options] [file…] ## 常用的选项有如下所列。 -b ## 按字节计算宽度，默认情况下，fold按列来计算宽度 -s ## 在空格处折断行 -w ## 指定宽度，默认值是80列 使用fmt命令格式化段落：fmt比fold提供了更多的功能。 ## -width选项指定文本行的列数，默认为75列 ## file为要格式化内容的文件名，可以同时指定多个文件，用空格隔开 ## 如果指定文件名为-，会从标准输入即键盘读取文本 fmt [-width] [option].</description>
    </item>
    
    <item>
      <title>Shell编程基础</title>
      <link>https://supersonnya.github.io/operation/linux/linux-shell_programbasical_two/</link>
      <pubDate>Thu, 01 Sep 2022 09:18:38 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-shell_programbasical_two/</guid>
      <description>函数 基本介绍 1、什么是函数 对于一个单独的 Shell 脚本来说，在执行的时候，会为其创建一个新的Shell 进程，来解释并执行脚本中的代码，当脚本执行完成，该 Shell 进程就会自动结束；而对于一个函数来说，在调用的时候，系统并不会为其单独创建一个 Shell 进程，而是在调用者的 Shell 进程中直接解释并执行函数中的代码。 2、函数的定义 Shell规定，函数必须在调用前定义。 [function] function_name () { statement1 statement2 ... statement n } 3、函数的调用 通过函数名来调用该函数：function_name param1 param2 …。 当用户定义一个函数后，该函数就成为一个合法的Shell命令，可在后继的脚本中使用。定义函数时需要使用圆括号，调用函数时无需圆括号。 4、函数链接 函数链接指在某个Shell函数中调用另外一个函数的过程，Shell允许用户函数的嵌套调用。 函数链接不仅仅局限于在某个函数中调用另外一个函数，还可进行多层嵌套调用，或在某个函数中调用多个函数。 5、函数的返回值 用户可使用return语句返回某个数值，在Shell中，return只能返回0～255之间的整数值。 在函数中，用户将需要返回的数据写入到标准输出，通常使用echo语句完成，然后在调用程序中将函数的执行结果赋给一个变量。通过echo可以将各种数据作为返回值返回给函数调用者，而不仅仅局限于整数。 6、函数和别名 与函数相比，别名的功能比较简单，不能为一组命令指定别名，别名中不能通过系统变量操作参数列表。 函数参数 1、含有参数的函数的调用方法 function_name arg1 arg2 ...。 2、获取函数参数的个数 在函数内部，通过位置变量来接收参数的值。 通过系统变量$#来获取脚本的参数的个数。 参数以空格隔开，如果某个参数中含有空格，应该使用引号将其引用起来。 3、通过位置变量接收参数值 使用位置变量来获取参数值，$0表示脚本名称，$1表示第1个参数，$2表示第2个参数等。通过系统变量$@和$*获取所有参数的值。 4、移动位置参数 在函数中，用户可以使用shift命令来使得脚本的所有的位置参数向左移动一个位置，使用户可通过9以内的位置变量来获取超过9个的参数。 shift命令会影响到系统变量$#的值。 5、通过getopts接收函数参数 getopts是bash内置的一个命令，该命令可以获取函数的选项以及参数值，或者是脚本的命令行选项以及参数值，基本语法：getopts optstring [args]。参数optstring包含一个可以被getopts命令识别的选项名称列表。如果选项名称的后面带冒号，表示可为该选项提供参数值，参数值将被保存到一个名称为$OPTARG的内置系统变量中。getopts命令会依次遍历每个选项，选项名称将被保存到args变量中。 6、间接参数传递 间接参数传递指通过间接变量引用来实现函数参数的传递。如果某个变量的值又是另外一个变量的变量名，则该变量称为间接变量。 变量的间接引用语法：${!var_name}。 7、通过全局变量传递数据 参数的作用是在主程序和函数之间传递数据。除了使用参数传递数据外，还可通过全局变量来传递。 8、传递数组参数 严格地讲，Shell不支持将数组作为参数传递给函数，但可通过一些变通的方法实现数组参数的传递。 #! /bin/bash func() { echo &amp;#34;number of elements is $#.</description>
    </item>
    
    <item>
      <title>Netapp存储</title>
      <link>https://supersonnya.github.io/operation/storage/storage-netapp/</link>
      <pubDate>Tue, 30 Aug 2022 09:25:24 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/storage/storage-netapp/</guid>
      <description>netapp硬盘更换 sysconfig -r ## 查看数据重建进度和磁盘状态 disk show -v ## 坏盘状态为failed aggr status -s | -f ## 查看热备盘|坏盘 priv set advanced ## 进入维护模式 blink_on diskname ## 点亮磁盘黄灯 disk assign diskname ## 分配磁盘 disk unfail -s diskname ## 将磁盘转换为热备盘 disk zero spares ## 格式化热备盘 rdfile /etc/messages ## 出现reconstruction completed可以更换硬盘 常用巡检命令 system health status show environment status ## 查看环境信息 version ## 查看OS版本 sysconfig -v ## 查看系统信息(设备序列号 系统软、硬件信息等) sysconfig -a ## 查看系统信息详情 sysconfig –v ## 查看基本配置 sysconfig -av sysconfig -r ## 查看RAID信息(spare盘及故障硬盘会在这里显示) license ## 查看许可信息 cf status ## 查看HA状态 qtree status ## 显示qtree状态 vif status VIF ## VIF所有端口是否正常 ifconfig -a ## 查看网络配置 disk show ## 查看磁盘分配信息 disk show -v ## 查看磁盘owner信息 disk show -r storage show disk aggr status ## 查看raid组信息 aggr status -r ## 查看raid组详情 vol status ## 查看卷状态 vol status -r ## 查看卷详情 lun show lun show -v ## 查看LUN信息 lun show -m ## 查看lun的map情况 igroup show ## 查看igroup信息 df -Vh ## 查看卷空间 df -Ah ## 查看aggr空间 df –i ## 查看卷的inode使用情况 snap list ## 查看快照情况 fcp status ## 查看FCP服务是否开启 fcp show initiator ## 查看FCP连接 fcp show adapter ## 查看FC端口 igroup show ## 查看map情况 igroup show -v ## 查看map详情 lun show -m ## 查看lun的map情况 sysstat -x 2 ## 查看系统当前性能信息 rdfile /etc/messages ## 查看系统日志信息 cluster show ## 集群状态检查 cluster statistics show ## 集群统计状态检查 node show ## 查看节点信息 system license show ## 查看序列号 system health subsystem show ## 查看子系统健康状态 metrocluster show ## 查看MCC集群信息状态及节点信息状态 system controller show ## 查看控制器状态 storage disk show -broken ## 查看故障硬盘 storage disk show -spare ## 查看spare硬盘 storage bridge show ## 查看SAS桥故障 storage switch show ## 查看光纤交换机故障 storage failover show ## 查看failover状态 event log show -severity critical ## 查看严重告警日志及错误告警日志 vol show -aggregate aggr_data_A1 ## 查看某个聚合下的Volume状态信息 run -node cluster1-01 ## 进入某一节点 vol status -s ## 节点下查看spare disks vol status -f ## 节点下查看fail disk disk show -n ## 显示没有ownership（归属权）的硬盘 disk assign all ## 分配硬盘的归属(硬盘更换常用） storage show disk -p ## 查看所有硬盘位置信息 disk show hostname ## 主机磁盘信息 storage show disk hostname ## 磁盘存储信息 Cluster Failover 双机双活配置，当一台机器发生故障，另一台可完全接管坏机的工作。 cf status ## 检查cluster状态 cf enable | cf disable ## 开启|关闭cluster cf takeover ## 强制接管 partner ## 在接管模式下切换到partner管理界面 cf giveback ## 在接管模式下,将接管的功能服务返回给原节点 OceanStor9000 show task general task_name=data_scrub ## result=failed pause task task_id ## Error: Failed to suspend a task continue task task_id ## 重新启动即可 </description>
    </item>
    
    <item>
      <title>Shell编程基础</title>
      <link>https://supersonnya.github.io/operation/linux/linux-shell_programbasical/</link>
      <pubDate>Thu, 25 Aug 2022 16:16:48 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-shell_programbasical/</guid>
      <description>变量和引用 深入认识变量 1、什么是变量 变量就是在程序中保存用户数据的一块内存空间，变量名就是这块内存空间的地址。 在程序的执行过程中，保存数据的内存空间的内容可能会不断地发生变化，代表内存地址的变量名保持不变。 2、变量的命名 变量名可以由字母、数字或者下划线组成，且只能以字母或者下划线开头，变量名的大小写是敏感的，变量名和等号之间不能有空格。 通常应尽可能选择有明确意义的英文单词作为变量名。 3、变量的类型 在Shell中，变量的数据类型无需显示地声明，变量的数据类型会根据不同的操作有所变化。Shell中的变量不分数据类型，统一地按照字符串存储。 为执行加法运算，Shell自动进行数据类型的转换，如果遇到含有非数字的字符串、空串、没有定义的变量，该变量将被转换成整数0。 4、变量的定义 当第一次使用某个变量名时就同时定义了这个变量，在变量的作用域内，都可以使用该变量。 使用命令来声明变量 ## attribute 表示变量的属性，常用的属性 ### -p 显示所有变量的值 ### -i 将变量定义为整数，如果求值失败或者不是整数，就设置为0 ### -r 将变量声明为只读变量，不允许修改，也不允许删除 ### -a 变量声明为数组变量 ### -f 显示所有自定义函数，包括名称和函数体 ### -x 将变量设置成环境变量，在随后的脚本和程序中可以使用 ### declare又写做typeset declare attribute variable ## 求表达式的值 x=$[6/3] x=$((6/3)) 5、变量和引号 Shell语言中一共有3 种引号，分别为单引号、双引号和反引号。 单引号括起来的字符都作为普通字符出现。 双引号括起来的字符，除“$”、“\”、“&#39;”、“&amp;quot;”这几个字符仍是特殊字符并保留其特殊功能外，其余字符仍作为普通字符对待。 反引号括起来的字串被Shell解释为命令，在执行时首先执行该命令，并以它的标准输出结果取代整个反引号部分。 6、变量的作用域 全局变量：全局变量可以在脚本中定义，也可以在某个函数中定义。在脚本中定义的变量都是全局变量，函数内部定义的变量默认情况下也是全局变量，其作用域为从被定义的地方开始，一直到脚本结束或者被显式地删除。 局部变量：仅限于某个程序段访问，在函数内部通过local关键字定义局部变量，函数的参数是局部变量。在出现同名的情况下，函数内部的局部变量会优先被使用。 Shell中变量的原型为${var}，常用的书写形式$var是一个简写。某些情况下，简写形式会导致程序执行错误。 7、系统变量 系统变量主要在对参数判断和命令返回值判断时使用，包括脚本和函数的参数，以及脚本和函数的返回值。 $n ## n是一个整数，从1开始，表示参数的位置 $# ## 命令行参数的个数 $0 ## 当前脚本的名称 $? ## 前一个命令或者函数的返回状态码 $* ## 以“参数 1 参数 2 ……”的形式将所有的参数通过一个字符串返回 $@ ## 以“参数 1 ”“参数 2 ”……的形式返回每个参数 $$ ## 返回本程序的进程ID（ PID ） 8、环境变量 Shell的环境变量是所有Shell 程序都可以使用的变量。环境变量会影响到所有脚本的执行结果。 可使用set命令列出所有的环境变量。 ## 常用的Shell环境变量 PATH ## 命令搜索路径，以冒号为分隔符，当前目录不在系统路径里 HOME ## 用户主目录的路径名，cd命令的默认参数 COLUMNS ## 定义了命令编辑模式下可使用命令行的长度 HISTFILE ## 命令历史文件 HISTSIZE ## 命令历史文件中最多可包含的命令条数 HISTFILESIZE ## 命令历史文件中包含的最大行数 IFS ## Shell使用的分隔符 LOGNAME ## 当前的登录名 SHELL ## Shell的全路径名 TERM ## 终端类型 TMOUT ## Shell自动退出的时间，单位为秒，设为0则禁止Shell自动退出 PWD ## 当前工作目录 变量的赋值和清空 1、变量赋值 赋值语法：variable_name=value。 如果value中包含空格、制表符和换行符，必须用单引号或者双引号引起来。 中间的等于号称为赋值符号，赋值符号的左右两边不能直接跟空格，否则Shell会将其视为命令。 Shell允许只包含数字的变量值参与数值运算。 2、引用变量的值 可通过在变量名前面加上$来获取变量的值。 为正确界定变量名，避免混淆，引用变量时使用大括号将变量名括起来：${v4}。 3、清除变量 变量不再需要时可以将清除，变量被清除后，代表的值也会消失：unset variable_name。 引用和替换 1、引用 引用是指将字符串用引用符号包括起来，以防止其中的特殊字符被Shell解释为其他涵义。 转义：反斜线屏蔽后的字符的特殊意义，\$SHELL。 全引用：当一个字符串被单引号引用起来之后，其中所有的字符，除单引号本身之外，都将被解释为字面意义。 部分引用：使用双引号将字符串引用起来，则其中所包含的字符除$、反引号、\外的其他字符，都将被解释为字面意义。 命令替换：反引号和圆括号，&#39;shell_command&#39;，$(shell_command)。 条件测试和判断语句 条件测试 1、基本语法 用户可以使用测试语句来测试指定的条件表达式的条件的真或者假。当指定的条件为真时，整个条件测试的返回值为0；如果指定的条件为假，则条件测试语句的返回值为非0值。 条件测试的语法有两种，分别是test命令和[命令。 ## expression表示需要进行测试的条件表达式 ## 可由字符串、整数、文件名，以及各种运算符组成 test expression ## [是条件测试命令，expression的语法与test命令中的语法相同 ## 条件表达式和左右方括号之间都必须有一个空格 [ expression ] 2、字符串测试 字符串中的字母是区分大小写的。 string ## 判断指定的字符串是否为空，只能使用test测试是否为空串 string1 = string2 ## 判断两个字符串 string1 和 string2 是否相等 string1 !</description>
    </item>
    
    <item>
      <title>Shell入门基础</title>
      <link>https://supersonnya.github.io/operation/linux/linux-shell_basical/</link>
      <pubDate>Wed, 24 Aug 2022 14:47:37 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-shell_basical/</guid>
      <description>什么是Shell Shell的存在，向普通的用户隐藏了许多关于系统内核的细节。Shell又称命令解释器，能识别用户输入的各种命令，并传递给操作系统。在UNIX或者Linux中，Shell既是用户交互的界面，也是控制系统的脚本语言。 获取当前系统默认Shell：echo $SHELL。 查看bash当前版本：echo $BASH_VERSION。 出于安全考虑，用户只能使用/etc/shells中列出的Shell。若要使用新的Shell，需要将其加入配置文件中。 Shell脚本程序执行方式： 交互式执行 [root@linux ~]$ for filename in &amp;#39;ls .&amp;#39; &amp;gt; do &amp;gt; if echo &amp;#34;$filename&amp;#34; | grep &amp;#34;xml&amp;#34; &amp;gt; then &amp;gt; echo &amp;#34;$filename&amp;#34; &amp;gt; fi &amp;gt; done 作为程序执行 将脚本文件授予用户执行权限之后，就可以执行脚本。 #! /bin/sh for filename in &amp;#39;ls .&amp;#39; do if echo &amp;#34;$filename&amp;#34; | grep &amp;#34;xml&amp;#34; then echo &amp;#34;$filename&amp;#34; fi done 向脚本传递参数 从命令行传递给Shell脚本的参数又称为位置参数，因为Shell脚本根据参数的位置来接收它们的值。 ## 常用的与参数传递有关的系统变量 $n ## 表示传递给脚本的第n个参数，$1 表示第1个参数 $# ## 命令行参数的个数 $0 ## 当前脚本的名称 $* ## 以&amp;#34;参数1 参数2 参数3 ……&amp;#34;的形式返回所有参数的值 $@ ## 以&amp;#34;参数1&amp;#34;&amp;#34;参数2&amp;#34;&amp;#34;参数3&amp;#34;……的形式返回所有参数的值 $_ ## 保存之前执行的命令的最后一个参数 对于包含空白字符或者其他的特殊字符的参数，需要使用单引号或者双引号进行传递。 如果用户传递的参数中包含空格或者其他的特殊字符，需使用$@来获取所有的参数的值，不能使用$*。 执行Shell程序 授予用户执行该脚本文件的权限: chmod u+x xxx.</description>
    </item>
    
    <item>
      <title>HTTP服务器</title>
      <link>https://supersonnya.github.io/operation/linux/linux-httpserver/</link>
      <pubDate>Mon, 22 Aug 2022 16:08:56 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-httpserver/</guid>
      <description>Apache基础 </description>
    </item>
    
    <item>
      <title>管理守护进程</title>
      <link>https://supersonnya.github.io/operation/linux/linux-daemonmanager/</link>
      <pubDate>Mon, 22 Aug 2022 10:09:55 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-daemonmanager/</guid>
      <description>系统引导 Linux启动的基本步骤 加载并初始化 Linux 内核。 配置硬件设备。 内核创建自发进程。 由用户决定是否进入手工引导模式。 （由 init 进程）执行系统启动脚本。 进入多用户模式。 init和运行级 Linux的init进程总共支持10个运行级，但实际定义的运行级只有7个。 0 ## 系统关闭 1 或 S ## 单用户模式，用于系统救援 2 ## 功能受限的多用户模式 3 ## 完整的多用户模式 4 ## 一般不用，留作用户自己定义 5 ## 多用户模式，运行 X 窗口系统 6 ## 重新启动 ## telinit 命令强制系统进入某个运行级 telinit 6 init的配置文件是/etc/inittab，文件中定义了每个运行级上需要做的事。inittab文件通常并不会列出所有应该执行的脚本，而是调用rc脚本（通常是/etc/init.d/rc）改变运行级。rc脚本随后根据传给它的参数查找与运行级有关的目录，并执行其中的脚本。 这些目录在/etc或/etc/init.d 目录下。 服务器启动脚本 用于启动服务器应用程序服务器守护进程的脚本全部位于/etc/init.d目录下，每个脚本控制一个特定的守护进程。所有的脚本都应该认识start和stop参数，分别表示启动和停止服务器守护进程。 init在执行脚本的时候，会给以字母S开头的脚本文件传递start参数，给以字母K开头的脚本文件传递stop参数。 脚本文件名中的数字描述了脚本运行的先后顺序，数字较小的脚本首先被执行。 管理守护进程 一种是随系统启动而启动，并持续在后台监听连接请求，称为standalone模式。 借助于inetd/xinetd，在需要的时候启动，完成任务后把监听任务交还给inetd/xinetd，称为inetd/xinetd模式。 并不是所有的服务器守护进程都支持inetd和xinetd。应用程序必须在编写的时候加入对这种模式的支持。 xinetd xinetd守护进程依照/etc/xinetd.conf配置执行。不推荐通过直接编辑/etc/xinetd.conf来添加服务，应为每个服务单独开辟一个文件，存放在/etc/xinetd.d目录下。 通过 xinetd 启动 SSH 服务 在xinetd中添加服务步骤 ## 修改（增加）配置文件 vi /etc/xinetd.d/ssh service ssh { socket_type = stream protocol = tcp wait = no user = root server = /usr/sbin/sshd server_args = -i log_on_success += DURATION disable = no } ## 停用该服务的守护进程 /etc/init.</description>
    </item>
    
    <item>
      <title>博科光交</title>
      <link>https://supersonnya.github.io/operation/network/network-switch_brocade_zone/</link>
      <pubDate>Thu, 18 Aug 2022 17:09:01 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/network/network-switch_brocade_zone/</guid>
      <description>常用命令 uptime ## 显示交换机工作时间 ipaddrshow ## 显示交换机IP地址信息 licenseshow ## 显示光前交换机所添加的license信息 switchshow ## 检查交换机信息及端口状态 switchstatusshow ## 显示交换机的运行状态 firmwareshow ## 显示微码版本 fanshow ## 显示风扇运行状态 tempshow ## 显示交换机当前温度信息 psshow ## 显示电源运行状态 slotshow ## 显示板卡运行状态 hashow ## 显示CP版卡HA状态, errdump ## 显示错误日志 fabricshow ## 显示fabric信息 cfgshow ## 显示交换机配置信息 porterrshow ## 显示交换机端口的错误统计 ## Frame(tx/rx)：tx代表端口发送的数据帧，rx代表端口收到的数据帧 chassisshow ## 显示外壳信息及序列号 version ## 查看版本 userconfig --show -a ## 查看登录帐号 domainsshow ## 查看交换机的domain信息 aliashow ## 查看别名 博科光交划Zone 规划好主机和存储模块在交换机上对应的端口。 确认交换机IP信息、域信息以及当前活跃cfg配置信息。 创建zone zonecreate &amp;#34;ocr_fc1&amp;#34;,&amp;#34;1,94;1,68;1,69&amp;#34; zonecreate &amp;#34;ocr_fc2&amp;#34;,&amp;#34;1,95;1,68;1,69&amp;#34; # 将zone添加到当前活动的cfg配置文件中 cfgadd &amp;#34;cfg01&amp;#34;,&amp;#34;ocr_fc1&amp;#34; cfgadd &amp;#34;cfg01&amp;#34;,&amp;#34;ocr_fc2&amp;#34; # 使cfg生效并保存cfg cfgenable &amp;#34;cfg01&amp;#34; cfgsave 删除zone并生效 cfgremove &amp;#34;CFG_NAME&amp;#34;,&amp;#34;ZONE_NAME&amp;#34; zonedelete &amp;#34;ZONE_NAME&amp;#34; cfgenable &amp;#34;CFG_NAME&amp;#34; cfgsave 备份配置 命令行或页面上传。 configupload ftp host Brocade SAN交换机常用命令 switchstatusshow ## 查看交换机的总体健康状态 switchshow ## 查看交换机基本配置信息 ## 查看端口状态 portshow portshow 0 fanshow ## 查看交换机散热风扇的状态 psshow ## 查看交换机的电源状态 ### 如果安装FR4-18i、FC4-16IP、FC10-6、FC8-48板，需要满配4个电源 tempshow ## 查看交换机的环境温度 ## 查看交换机的内部消息日志 errdump、errshow、errclear ## 显示诊断信息和状态信息 supportshow ## 将数据打包、上传至指定的FTP服务器 supportSave ## 显示panic dump文件的内容，帮助诊断系统panic的原因 pdshow ## 检查连接到交换机的设备 nsshow ## 显示连接到交换机的所有设备 nsallshow ## 显示连接到Fabric的所有设备 ## 显示Fabric中的所有交换机 fabricshow ## 检查license文件和交换机的WWN号 licenseshow、wwn ## 检查Fabric OS的版本 version ## 查看Control Blade的状态 hashow ## 查看各个Blade的状态 slotshow ## 修改端口的速率 portcfgspeed ## Reset端口 portenable或portcfgpersistentenable 检查WWN卡状态 www，chassisShow：显示交换机的WWN号 chassisShow：显示chassis和WWN卡的状态 ipAddrShow，ipAddrSet：显示CP Blades的IP地址 historyShow、historyLastShow：显示历史日志信息 switchName：显示交换机的名字 修改Domain ID 1.</description>
    </item>
    
    <item>
      <title>Middleware Whatismiddleware</title>
      <link>https://supersonnya.github.io/operation/middleware/middleware-whatismiddleware/</link>
      <pubDate>Thu, 18 Aug 2022 16:49:48 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/middleware/middleware-whatismiddleware/</guid>
      <description>1. 中间件是什么 中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯，是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。通过中间件，应用程序可以工作于多平台或 OS 环境。 中间件是介于操作系统和应用软件之间，为应用软件提供服务功能的软件，有消息中间件，交易中间件，应用服务器等。由于介于两种软件之间，所以，称为中间件。 中间件屏蔽了底层操作系统的复杂性，使程序开发人员面对一个简单而统一的开发环境，减少程序设计的复杂性，将注意力集中在自己的业务上，不必再为程序在不同系统软件上的移植而重复工作，从而大大减少了技术上的负担。中间件带给应用系统的，不只是开发的简便、开发周期的缩短，也减少了系统的维护、运行和管理的工作量，还减少了计算机总体费用的投入。 2. 主要中间件的分类 2.1 Hadoop Hadoop就是一个分布式计算平台，用Java语言开发，包含 Common、MapReduce 和HDFS三个核心部件（HDFS 和 MapReduce 是最核心的两个部件）。其中： Common 为 Hadoop 的其他项目提供了一些常用工具，主要包括系统配置工具 Configuration、远程过程调用 RPC、序列化机制和 Hadoop 抽象文件系统等。 MapReduce 是处理海量数据的计算模型。 而 HDFS 用于存储海量数据，它具备高度容错性，能在低成本的通用硬件机器上稳定运行。 Hadoop 实现了分布式计算中的基础算法（如一致算法、选举算法、故障检测、快照等），同时为用户提供了编程和命令接口。程序员调用这些函数能轻松写出分布式应用程序。 基于 Hadoop 平台衍生出来的开源项目主要有 Yarn、HBase、Hive、ZooKeeper、Avro、Sqoop、Mahout、Crossbow 等。 用 Hadoop 构建的应用实例对于计算资源的消耗具备两个明显的特征：资源需求量大；资源需求具备季节性。 2.2 LVS(Linux Virtual Server) 把许多台物理Linux计算机逻辑上整合成一台超级计算机，对用户来说感觉只有一台计算能力很强的服务器。LVS 就是一个由软件实现的负载均衡器，工作在网络OSI的第四层（应用层）。负载均衡器的作用就是把任务分配给最合适的服务器。 两个较为流行的第七层负载均衡器是 Nginx 和 HAProxy，针对应用做均衡，所以能适应的负载种类没有 LVS 多。 2.3 Linux-HA 如果负载均衡器出现故障，那么整个系统（如网店）将会瘫痪。所以人们开发了各种集群软件，如 Linux-HA 和 Keepalive 等。集成故障转移集群软件的核心思想是，实时检测故障机器并及时让好的机器接管工作，对外提供高可用性。 Linux-HA组件： Heartbeat：负责维护集群中各节点的信息及它们之间的心跳通信。 Pacemaker：集群资源管理器，是核心组件，客户端通过 Pacemaker 来配置、管理并监控整个集群。 Resource Agent：为用于控制服务启停、监控服务状态的脚本集合，本地资源管理器（LRM）调用这些脚本来启动、停止、监控各种集群资源。 Cluster Glue：包含一套函数库和工具，在集群栈中，除集群消息传输（由 Heartbeat 承担）、集群资源管理（由 Pacemaker 承担）和资源代理（由 Resource Agent 承担）功能外，其他功能都由 Cluster Glue 来完成。它包含的两个主要部分是 LRM 和 Stonith，前者是本地资源管理器，后者的任务是隔离故障机器。 2.</description>
    </item>
    
    <item>
      <title>Database Oracle_tablespaceanddatafile</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_tablespaceanddatafile/</link>
      <pubDate>Thu, 18 Aug 2022 16:29:00 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_tablespaceanddatafile/</guid>
      <description>表空间和数据文件的关系 一个数据库包含多个表空间，每个表空间包含一个或多个数据文件。创建表空间时必须创建数据文件，增加数据文件时必须指定表空间。一个段只能驻留在一个表空间内，段的下一层是盘区，一个或多个盘区组成一个段，每个盘区只能驻留在一个数据文件中，若一个段跨越多个数据文件，就只能由多个驻留在不同数据文件中的盘区构成。盘区的下一层是数据块，是磁盘空间管理中逻辑划分的最底层，一组连续的数据块组成一个盘区。 -- 表空间和对应数据文件的关系从dba_data_files数据字典中查询 select tablespace, file_name, bytes from dba_data_files; Oracle 11g的默认表空间 默认表空间是在创建数据库时，系统自动创建的表空间，用于存放Oracle系统内部数据和提供样例所需要的逻辑空间。 -- 安装时选择实例方案，存放个样例的数据 EXAMPLE -- 存放数据字典，包括表、视图、存储过程的定义等 SYSTEM -- SYSTEM的辅助空间，存放一些选件的对象，减少SYSTEM表空间的负荷 -- 可以增加数据文件和监视等操作，但不能执行删除、重命名或设置只读等操作 SYSAUX -- 存放SQL语句处理的表和索引的信息，如数据排序 TEMP -- 存放撤销数据 UNDOTBA1 -- 存放应用系统所使用的数据库对象 USERS 创建表空间 为简化表空间管理并提高系统性能，Oracle建议将不同类型的数据对象存放到不同的表空间中。在创建数据库之后，还应根据具体应用建立不同类型的表空间。 创建小文件表空间还是大文件表空间，默认小文件。 使用局部盘区管理方式，还是使用传统目录盘区管理方式，默认局部盘区管理。 手工管理段空间，还是自动管理，默认自动管理。 是否使用临时段或撤销段的特殊表空间。 创建表空间语法 CREATE [SMALLFILE|BIGFILE] TABLESPACE tablespace_name DATAFILE &amp;#39;/path/filename&amp;#39; SIZE num [k|m] REUSE -- reuse表示若文件存在，吃；出该文件再重建建立 [, &amp;#39;/path/filename&amp;#39; SIZE num [k|m] REUSE] [, ...] [AUTOEXTEND [ON|OFF] NEXT num[k|m] -- 若自动扩展，需要设置next值 [MAXSIZE [UNLIMITED | num[k|m]]]] -- 自动扩展的最大值 [MININUM EXTENT num [k|m]] -- 指定最小长度，由操作系统和数据库块决定 [DEFAULT STORAGE storage] -- 指定以后要创建的表、索引及簇的存储参数值 [ONLINE | OFFLINE] -- 创建表空间可指定在线或离线 [LOGGING | NOLOGGING] -- 加载表空间内表的时候是否产生日志，默认产生日志 [PERMANENT | TEMPORARY] -- 永久表空间还是临时表空间，默认为永久表空间 [EXTENT MANAGEMENT DICTIONARY | LOCAL -- 表空间的扩展方式使用数据字典管理还是本地化管理，默认本地化 [AUTOALLOCATE | UNIFORM SIZE num[k|m]]] -- 若采用本地化管理，扩展时指定每次盘区扩展大小是系统自动指定还是按照等同大小进行，若按照等同大小，默认每次扩展大小为1mb 通过本地化管理方式创建表空间 本地化表空间管理使用位图跟踪表空间对应的数据文件的自由空间和块的使用状态，位图中每个单元对应一个块或一组块。当分配或释放一个扩展时，Oracle会改变位图的值以指示该块的状态。位图值得改变不会产生回滚信息。本地管理表空间有以下优点： 使用本地化得扩展管理功能可以避免发生重复的空间管理操作。 本地化管理的自动扩展能够跟踪临近的自由空间，可以消除结合自由空间的麻烦。 通过段空间管理方式创建表空间 段空间管理方式是建立在本地化空间管理方式基础之上的，只有本地化管理方式的表空间，才能在其基础上进一步建立段空间管理方式。段空间管理又分为手工段和自动段两种方式。 SEGMENT SPACE MANAGEMENT MANUAL/AUTO 手工段空间管理方式 手工段空间管理方式是为了向后兼容而保留，使用自由块列表和PCT_FREE和PCT_USED参数来标识可供插入操作使用的数据块。 每个INSERT或UPDATE操作后，比较数据块中剩余自由空间和PCT_FREE设置，小于则从自由块列表移除。 每个UPDATE或DELETE操作后，比较数据块中已用空间和PCT_USED设置，小于则加入自由块列表。 自动段空间管理方式 使用位图标识可用于插入操作的数据块，及需要从自由块列表取下的数据块。PCT_FREE和PCT_USED参数会被自动忽略，比手工段空间管理方式具有更好的性能，是创建表空间时的首选方式。 自动段空间不能用于创建临时表空间和系统表空间。 默认情况是手工管理方式，创建表空间时需明确指定AUTO。 创建非标准块表空间 通常块大小为8kb，允许创建大小与基本块不同的表空间，块大小由创建表空间时的BLOCKSIZE指定，有利于存储不同大小的对象。 非标准块的大小为基本块的倍数。 块较大的表空间通常用来存放大对象（LOB）类型。 Oracle 11通常使用SGA自动共享内存管理，需要设置初始化参数DB_16K_CACHE_SIZE=16K。 维护表空间和数据文件 管理撤销表空间 管理临时表空间 </description>
    </item>
    
    <item>
      <title>Database Oracle_controlandlogfiles</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_controlandlogfiles/</link>
      <pubDate>Thu, 18 Aug 2022 16:28:08 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_controlandlogfiles/</guid>
      <description>管理控制文件 控制文件是Oracle数据库最重要的物理文件之一，每个Oracle数据库至少有称控制文件。启动数据库实例时，根据初始化参数查找控制文件并读取控制文件中的内容，然后根据控制文件中的信息在实例和数据库之间建立起关联。如果无法找到控制文件或控制文件被损坏，数据库实例将无法启动，且很难修复。 控制文件简介 Oracle数据库中，控制文件是一个很小（10MB范围内）的二进制文件，含有数据库的结构信息，包括数据文件和日志文件。控制文件在数据库创建时被自动创建，在数据库发生物理变化时更新。任何时候都不要手动编辑控制文件。 Oracle系统提供了备份文件和多路复用的机制，当控制文件损坏时，用户可以通过先前的备份来恢复控制文件。 及时备份控制文件 当数据库的物理组成发生变化时，控制文件也会变更，需要及时备份控制文件。 保护控制文件 采用多种策略或准则保护控制文件，目前主要有多路复用控制文件和备份控制文件。 控制文件的多路复用 至少建立两个控制文件，并且两个控制文件最好分别保存在不同的磁盘中，避免由于某个磁盘故障而发生无法启动数据库的风险。即在系统不同的位置上同时存放多个控制文件的副本。 初始化参数CONTROL_FILES中列出了当前数据库所有的控制文件名，Oracle根据CONTROL_FILES参数中的信息同时修改所有的控制文件，但只读取其中第一个控制文件的信息。在整个数据库运行期间，如果任何一个控制文件被损坏，实例就不能再继续运行。 实现多路复用包括更改CONTROL_FILES参数和复制控制文件两个步骤： 更改CONTROL_FILES参数：在SPFILE中，使用ALTER SYSTEM更改CONTROL_FILES参数值。 停止Oracle服务，关闭数据库，并将第一个控制文件复制到新增加的目录下并重命名，启动数据库验证。 创建控制文件 如果突发意外，导致数据库的所有控制文件全部丢失或损坏，只能手工创建一个新的控制文件。 CREATE CONTROLFILE REUSE DATABASE db_name LOGFILE GROUP 1 redofiles_list1 GROUP 2 redofiles_list2 GROUP 3 redofiles_list3 ... DATAFILE datafile1 datafile2 datafile3 ... MAXLOGFILES max_value1 -- 永久性参数 MAXLOGMEMBERS max_value2 -- 永久性参数 MAXINSTANCES max_value3 -- 永久性参数 MAXDATAFILES max_value4 -- 永久性参数 NORESETLOGS|RESETLOGS ARCHIVELOG|NOARCHIVELOG; 若需要修改数据库的某个永久性参数，必须重新创建控制文件。 创建控制文件过程 查看数据文件和重做日志文件：若数据库中所有的控制文件和日志文件已经丢失，数据库已无法打开，就无法通过查询数据字典来获得数据文件和日志文件信息，只能查看告警日志文件中的内容。如果数据库可以打开，在v$logfile查看日志文件，在v$datafile查看数据文件，在v$controlfile查看控制文件。 关闭数据库：若数据库处于打开状态，在system模式使用SHUTDOWN IMMEDIATE关闭数据库。 备份文件：在操作系统备份国有的数据文件和重做日志文件，在使用CREATE CONTROLFILE创建新控制文件时，可能损坏数据文件和日志文件。 启动数据库实例：启动但不加载数据库。 创建新的控制文件：使用CREATE CONTROLFILE创建一个新的控制文件。 编辑参数：编辑SPFILE文件中的CONTROL_FILES参数，使其指向新建的控制文件。 打开数据库：alter database open。若创建控制文件使用了RESETLOGS语句，需要以恢复方式打开数据库，alter database open resetlogs。 备份和恢复控制文件 备份控制文件 控制文件有两种备份方式，备份为二进制文件或脚本文件。 备份为二进制文件：ALTER DATABASE BACKUP CONTROLFILE TO file_path;。 备份为脚本文件：ALTER DATABASE BACKUP CONTROLFILE TO TRACE;。脚本文件以文本形式备份，也称为跟踪文件，实际是一个SQL脚本，可以利用它来重新创建新的控制文件，跟踪文件存放位置由USER_DUMP_DEST参数决定。 恢复控制文件 控制文件损坏后，重新指定CONTROL_FILES参数，使它指向备份的控制文件，即可重新启动数据库。 控制文件本身损坏，目录仍可访问：关闭数据库，复制一个多路复用文件覆盖损坏文件，重新启动数据库。 磁盘介质永久性损坏：关闭数据库实例，修改初始化参数指向新的控制文件，重新启动数据库。 删除控制文件 关闭数据库，编辑初始化参数CONTROL_FILES，清除需要删除的控制文件名称，重新启动数据库。 不能将控制文件全部删除，至少保留两个，否则数据库将无法启动。 查询控制文件信息 -- 包含所有控制文件的名称和状态信息 v$controlfile -- 包含控制文件中各个记录文档段的信息 v$control_record_section -- 包含系统所有初始化参数 v$parameter 管理重做日志文件 重做日志文件通常也称为日志文件，是保证数据库安全和数据库备份和恢复的文件，管理员可以根据日志文件和数据库文件，将崩溃的数据库恢复到最近一次记录日志时的状态。 重做日志文件 重做日志文件用于记载事务操作引起的数据变化，当执行DDL或DML操作时，由LGWR进程将缓冲区中与该事务相关的重做记录全部写入重做日志文件。当丢失或损坏数据库中的数据时，Oracle会根据重做日志文件中的记录恢复丢失的数据。 日志文件的内容及数据恢复 重做日志文件由重做记录组成，重做记录又称为重做条目，由一组变更向量组成。每个变更向量都记录了数据库中某个数据块所做的修改。 利用重做记录，不禁能够恢复对数据文件所做的修改操作，还能恢复对回退段所做的修改操作。 重做记录以循环方式在SGA区的重做日志高速缓冲区中进行缓存。当一个事务被提交时，LGWR将该事务相关的所有重做记录全部写入重做日志文件中，同时生成一个系统变更码（SCN）。系统变更码会随着重做记录一起保存到重做日志文件组中，以标识与重做记录相关的事务。只有当某个事务所产生的重做记录全部被写入重做日志文件后，才会认为该事务提交成功。 正在被LGWR进程写入的重做日志文件处于当前状态；正在被实例用于数据库恢复的重做日志文件处于活动状态；其他重做日志文件处于未活动状态。可查询v$logfile获取重做日志文件的状态。 增加日志组及其成员 一个数据库至少需要两个重做日志文件组，每个组可以包含一个或多个重做日志成员。对于重做日志文件的日常维护工作，需要具有ALTER DATABASE系统权限。Oracle会自动为新建的重做日志组设置编号，一般是在当前最大组号之后递增。也可指定编号，但日志组编号必须是连续的，不能跳跃。 添加新的重做日志文件组 -- 通常大小10M-50M，默认为50M ALTER DATABASE ADD LOGFILE [GROUP num] (&amp;#39;filename1&amp;#39;,&amp;#39;filename2&amp;#39;) SIZE 20M; -- 添加一个单一的重做日志文件，并覆盖已存在的同名日志文件 -- 使用reuse时不能使用size，大小由已存在日志文件的大小决定 ALTER DATABASE ADD LOGFILE &amp;#39;filename&amp;#39; REUSE; 创建日志成员文件 -- 为重做日志组添加新成员 -- 可通过指定重做日志文件组中其他成员名称确定重做日志组 ALTER DATABASE ADD LOGFILE MEMBER &amp;#39;filename&amp;#39; TO filename | GROUP num; 删除重做日志文件 -- 删除日志成员，只在数据字典和控制文件中删除，物理文件需手动删除 ALTER DATABASE DROP LOGFILE MEMBER &amp;#39;filename&amp;#39;; -- 删除日志文件组：不再使用或大小不合适时需要删除 -- 无论日志组有多少成员，一个数据库至少需要两个日志组；只能删除处于INACTIVE的日志组；若数据库处于归档模式 -- 删除前必须确定已经被归档，可查询v$log查看重做日志文件组的状态及是否归档 ALTER DATABASE DROP LOGFILE GROUP num; -- 清空重做日志文件，重做日志组处于CURRENT状态可执行 ALTER DATABASE CLEAR LOGFILE GROUP num; -- 若要清空的重做日志文件组未归档，还需使用ALTER DATABASE CLEAR UNARCHIVED LOGFILE 更改重做日志文件的位置或名称 关闭数据库：shutdown。</description>
    </item>
    
    <item>
      <title>Database Oracle_plsqlblock</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_plsqlblock/</link>
      <pubDate>Thu, 18 Aug 2022 16:27:12 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_plsqlblock/</guid>
      <description>存储过程 存储过程是一种命名的PL/SQL块，既可以没有参数，也可以有若干个输入、输出参数，或有多个既作为输入又作为输出的参数，通常没有返回值。存储过程被保存在数据库中，不可以被SQL语句直接执行或调用，只能通过EXECUTE命令执行或在PL/SQL块内部被调用。存储过程是已经编译好的代码，调用时执行效率非常高。 -- 创建存储过程 -- parameter是存储过程被调用/执行时用到的参数，而不是存储过程内定义的内部变量，类型不能指定长度 CREATE [OR REPLACE] PROCEDURE pro_name [(parameter1 [IN|OUT] [,parameter2]...)] IS|AS BEGIN plsql_sentences; [EXCEPTION] [dowith_sentences;] -- 异常处理语句 END [pro_name]; -- 调用存储过程 EXEC | EXECUTE pro_name; 存储过程的参数 IN模式：输入类型，由调用方传入，只能被存储过程读取，默认模式。参数类型不能指定长度。位于参数名称之后。
指定名称传递参数：pro_name(parameter=&amp;gt;value1[,parameter2=&amp;gt;value2]...)，与定义顺序无关，与参数个数有关。 按位置传递：提供的参数值顺序必须与存储过程中定义的参数顺序相同。 混合方式传递：在某个位置使用指定名称传递方式传入参数后，后面也要使用指定名称传递。因为指定名称传递方式有可能已经破环了参数原始的定义顺序。 OUT模式：输出类型参数，表示此参数已在存储过程中被赋值，可以传递到存储过程之外的环境中，位于参数名称之后。
在PL/SQL块中调用OUT模式，需要在DECLARE部分定义与存储过程中OUT参数兼容的若干变量。 使用EXEC执行OUT模式的存储过程，需要在SQL*PLUS环境中使用VARIABLE声明变量，用于存储OUT参数的返回值。 IN OUT模式：调用存储过程时，从外界向该参数传入值，存储过程执行完毕后，该参数的返回值被传回给外界。
IN参数的默认值 支持在IN参数声明的同时初始化默认值，传值时若带默认值的参数不传值，建议使用指定名称传递参数。 删除存储过程 DROP PROCEDURE pro_name; 函数 存储在数据库中的命名程序块，函数一般用于计算和返回一个值，函数的调用是表达式的一部分，过程的调用是一条PL/SQL语句。函数必须有一个返回值，过程则没有。 创建函数 函数可以接受零或多个输入参数，并且必须有返回值。由于函数有返回值，在主体部分必须使用RETURN语句返回函数值，并且返回值类型与声明时的类型一致。 CREATE [OR REPLACE] FUNCTION fun_name[(parameter1[,parameter2]...)] RETURE data_type IS [inner_variable] BEGIN plsql_sentence; [EXCEPTION] [dowith_sentences;] END [fun_name]; 调用函数 由于函数有返回值，调用函数时，必须使用一个变量保存函数的返回值。 DECLARE variable_name data_type; BEGIN variable_name:=fun_name(value); END; 删除函数 DROP FUNCTION fun_name; 触发器 触发器可以看作一种特殊的存储过程，定义了一些在数据库相关事件发生时应执行的功能代码块，通常用于管理复杂的完整性约束，或监控对表的修改，或通知其他程序，也可实现对数据的审计功能。 能够引起触发器运行的操作被称为触发事件，如执行DML语句，执行DDL语句，引发数据库系统事件，引发用户事件。 创建触发器 触发器根据触发事件和触发器执行情况，分为5类。 行级触发器：DML语句对每一行数据进行操作时都会触发。在行级触发器中，可以访问当前正在受影响的数据行，可以通过行标识符来实现，列标识符分为原值标识符(:old.</description>
    </item>
    
    <item>
      <title>Database Oracle_plsql</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_plsql/</link>
      <pubDate>Thu, 18 Aug 2022 16:26:25 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_plsql/</guid>
      <description>PL/SQL简介 PL/SQL是一种过程化语言，可以控制程序的执行流程、定义变量，实现比较复杂的业务逻辑，是Oracle的专用语言，是对标准SQL语言的扩展，可在内部使用SQL语句。 PL/SQL块结构 PL/SQL程序以块为基本单位，整个PL/SQL块分布3部分：声明、执行、异常处理。 每一条语句都必须以分号结束，每条SQL语句可以写成多行的形式，也必须以分号结束。一行中可以有多条SQL语句，之间必须用分号分隔。 [DECLARE] -- 声明部分，可选。声明块中用到的变量、常量、游标等，只能在当前块中使用 BEGIN -- 执行部分，必需。整个块的主体，包括主要的逻辑控制和运算 [EXCEPTION] -- 异常处理，可选。处理执行部分出现的异常，执行完毕整个块直接结束 END 代码注释和标识符 注释 -- 单行注释 /* 多行注释 */ 标识符 定义变量、常量时，每行只能定义一个变量或常量，以分号结尾。 定义变量、常量时，名称必须以英文字符开头，最大长度为30个字符。若以其他字符开始，用双引号引住。 定义变量、常量时，名称只能使用字母、数字、_、$、#。若使用其他字符，用双引号引住。 定义变量、常量时，不能使用Oracle关键字，若使用，必须用双引号引住。 除了由引号引起来的字符串以外，PL/SQL不区分字母的大小写。标准PL/SQL字符集时ASCII字符集的一部分。 分界符 分界符是对PL/SQL有特殊意义的符号，用来将标识符相互分隔开。 文本 数字文本：整数或浮点数，可使用科学计数法和幂操作符**。 字符文本：用单引号引住的单个字符，可以是PL/SQL支持的所有可打印字符。 布尔文本：TRUE、FALSE、NULL。主要用于条件表达式。 日期时间文本：日期时间值。日期文本必须用单引号引住且与日期格式和日期语言匹配。 字符串文本：两个或两个以上字符组成的多个字符值，必须用单引号引住。 10g之前，若字符串文本包含单引号，必须用两个单引号表示。10g之后，可以使用其他分隔符赋值。 -- 10g之前 string_var:=&amp;#39;I&amp;#39;&amp;#39;m a string.&amp;#39;; -- 10g之后 string_var:=q&amp;#39;[I&amp;#39;m a string.]&amp;#39; 数据类型、变量和常量 数据类型是描述数据存储的内存结构，它决定变量中所存储的数据的类型。变量是一种用名称进行识别的标识符号，可以存储不同类型的值。 基本数据类型 数值类型 NUMBER：存储整数或浮点数。可使用NUMBER(p,s)格式化数字，p表示精度（所有有效数字的个数），s表示刻度范围（小数点右边小数位的个数）。 BINARY_INTEGER：存储整数。 PLS_INTEGER：存储整数。 NUMBER的子类型(等价的类型别名)：DEC|DECIMAL|DOUBLE|INTEGER|INT|NUMERIC|SMALLINT。 字符类型 VARCHAR2(maxlength)：存储长度可变的字符串，maxlength定义时必须给出，没有默认值。 maxlength最大为32767，数据库类型VARCHAR2最大长度为4000，所以大于4000的PL/SQL变量不可以赋值给数据库的变量，只能赋值给LONG类型的数据库变量。 CHAR(maxlength)：指定长度的字符串，默认长度为1，最大32767。如果赋给CHAR的值小于maxlength，后面用空格补全。数据库类型中的CHAR只有2000字节。 LONG：可变字符串，最大长度32767字节，数据库类型的LONG最大可达2GB。 NCHAR|NVARCHAR2：PL/SQL8.0以后加入的类型，长度根据各国字符集确定。 日期类型 DATE：存储日期和时间信息，存储空间7个字节，分别存储世纪、年、月、天、小时、分钟、秒。 布尔类型 BOOLEAN：流程控制和业务逻辑判断，值为TRUE、FALSE、NULL。 特殊数据类型 %TYPE类型 使用%TYPE可以声明一个与指定列相同的数据类型，通常跟在指定列名的后面。 declare var_ename scott.</description>
    </item>
    
    <item>
      <title>Database Oracle_sqlbasical</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_sqlbasical/</link>
      <pubDate>Thu, 18 Aug 2022 16:26:14 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_sqlbasical/</guid>
      <description>SQL语言简介 SQL，结构化查询语言，是一种在关系型数据库中定义和操纵数据的标准语言。 SQL语言的特点 SQL是一种非过程化语言，让用户不用考虑诸如数据的存储格式和存储路径等复杂问题就能按照自己的要求在高层数据结构上操作。 综合统一、集合性、统一性、高度非过程化、语言简单，易学易用、以同一种语法结构提供两种使用方式、是所有关系数据库的公共语言。 SQL语言的分类 数据查询语言（DQL） 检索数据库中的数据，主要是SELECT。 数据操纵语言（DML） 改变数据库中的数据，主要包括INSERT、UPDATE、DELETE。CALL、LOCKTABLE、MERGE。 事务控制语言（TCL） 维护数据的统一性，包括COMMIT、ROLLBACK、SAVEPOINT。 数据定义语言（DDL） 建立、修改和删除数据库对象，包括CREATE、ALTER、DROP。TRUNCATE。 数据控制语言（DCL） 执行权限授予和权限收回操作，包括GRANT、REVOKE。 SQL语言的编写规则 SQL关键字不区分大小写，字符值区分大小写。 用户模式 为便于管理用户创建的数据库对象，引入模式概念，某个用户创建的数据库对象属于该用户模式。 模式与模式对象 模式是一个数据库对象的集合，模式名称与数据库用户名称相同。在一个模式内部不可以直接访问其他模式的数据库对象，即使具有访问权限，也需要指定模式名称才可以访问。 模式对象是用户创建的逻辑结构，用以存储或引用数据，包括段以及用户拥有的其他非段的数据库对象。模式拥有模式对象。 一个不为某个用户所拥有的数据库对象不能被称为模式对象，如角色、表空间、目录等数据库对象。 查询用户模式表 在用户模式下，查询user_tables。 在system模式下，查询dba_tables。 检索数据 -- 检索基本语法格式 SELECT {[ DISTINCT | ALL] columns | *} [INTO table_name] FROM {tables | views | other SELECT }[WHERE conditions] [GROUP BY columns] [HAVING conditions] [ORDER BY columns] 简单查询 只包含SELECT子句和FROM子句的查询。 在Oracle数据库中，ROWID是行标识符，是内部使用的隐藏列，长度为18字符，包含该行数据的物理地址。使用DESCRIBE无法显示，但可在SELECT语句中检索。 查询日期列 -- 以简体中文显示日期结果 alter session set nls_date_language = &amp;#39;SIMPLIFIED CHINESE&amp;#39;; -- 以美国英语显示日期结果 alter session set nls_date_language = &amp;#39;AMERICAN&amp;#39;; -- 以特定格式显示日期结果 alter session set nls_date_format = &amp;#39;YYYY&amp;#34;年&amp;#34;MM&amp;#34;月&amp;#34;DD&amp;#34;日&amp;#34;&amp;#39;; 处理NULL值 NULL表示未知值，既不是空，也不是0，插入数据时不提供值且未设置默认值，则结果为NULL。实际应用中，NULL显示结果往往不符合要求，需使用NUL函数，转换为合理的结果。</description>
    </item>
    
    <item>
      <title>Database Oracle_sqlplus</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_sqlplus/</link>
      <pubDate>Thu, 18 Aug 2022 16:25:52 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_sqlplus/</guid>
      <description>SQL*PLUS与数据库的交互 SQL*PLUS是一个基于C/S两层结构的客户端操作工具，客户层和服务器层可在不同主机上。 设置SQL*PLUS的运行环境 运行环境是用来输入、执行SQL*PLUS命令和显示返回结果的场所。 SET命令 用户可以使用SET命令设置运行环境。通过SET设置的环境变量是临时的，退出环境后全部丢失。 -- system_variable:变量名 value:变量值 SET system_variable value -- 常用变量设置 -- PAGESIZE:设置从顶部标题至页结束之间的行数，包括分割线和空行，默认value=14 SET PAGESIZE value -- NEWPAGE:设置一页中空行的数量，默认value=1 SET NEWPAGE value -- LINESIZE:设置一行中所显示的最多字符总数，默认value=80 SET LINESIZE value -- PAUSE:设置输出结果是否滚动，value=OFF|ON|text，默认OFF，设置ON再设置text，每次暂停显示text SET PAUSE value -- NUMFORMAT:设置数值的默认显示格式，掩码：9，0，$，S，. SET NUMFORMAT format 常用SQL*PLUS命令 SQL*PLUS命令执行完成后，不保存在SQL缓冲区。 -- 提供被查询命令的标题、功能描述、缩写形式和参数选项，?表示命令的部分字符 HELP|? [topic] -- 查询指定数据对象的组成结构，包括表、视图、过程、函数和程序包等 DESC[RIBE] object_name; -- 将查询结果输出到指定文件，默认CREATE，OFF|OUT表示关闭SPOOL，关闭输出之后，才能在文件中看到内容 SPO[OL] [file_name[.ext] [CRE[ATE] | REP[LACE] | APP[END]] | [OFF | OUT] -- 定义一个用户变量并分配一个CHAR值 DEF[INE] [variable] | [variable = text] -- 显示SQL*PLUS系统变量或环境变量的值 -- option常用选项有ALL/PARAMETERS [parameter_name]/SGA/SPOOL/USER等 SHO[W] option -- 在记事本中编辑SQL缓冲区中的最近一条SQL语句或PL/SQL块，不加参数表示直接编辑最近一条 -- 执行最近一条SQL语句，可以运行`/`来执行 EDIT [file_name[.</description>
    </item>
    
    <item>
      <title>Database Oracle_structure</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_structure/</link>
      <pubDate>Thu, 18 Aug 2022 16:25:40 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_structure/</guid>
      <description>Oracle 11g体系结构概述 Oracle数据库是一格逻辑概念，而不是物理概念上安装了Oracle数据库管理系统的服务器。Oracle数据库管理系统有3个重要概念：实例、数据库和数据库服务器。 实例是指一组Oracle后台进程以及在服务器中分配的共享内存区域；数据库是由基于磁盘的数据文件、控制文件、日志文件、参数文件和归档日志文件等组成的物理文件集合；数据库服务器是指管理数据库的各种软件工具（如SQL-Plus、OEM等）和实例及数据库3个部分。从实例与数据库之间的辩证关系来讲，实例用于管理和控制数据库；而数据库为实例提供数据。一个数据库可以被多个实例装载和打开；而一个实例在其生存期内只能装载和打开一个数据库。 数据库的主要功能就是存储数据，数据库存储数据的方式通常称为存储结构，Oracle数据库的存储结构分为逻辑存储结构和物理存储结构。逻辑存储结构用于描述Oracle内部组织和管理数据的方式，物理存储结构用于展示Oracle在操作系统中的物理文件组成情况。 SQL命令从客户端发出后，由Oracle的服务器进程进行响应，然后在内存区域中进行语法分析、编译和执行，接着将修改后的数据写入数据文件，将数据库的修改信息写入日志文件，最后将SQL的执行结果返回给客户端。 逻辑存储结构 Oracle的逻辑存储结构是一种层次结构，主要由表空间、段、数据区和数据块等概念组成。逻辑结构是面向用户的，当用户使用Oracle设计数据库时，其使用的就是逻辑存储结构。 数据块 数据块（Data Block）是Oracle逻辑存储结构中的最小的逻辑单位，也是执行数据库输入／输出操作的最小存储单位。Oracle数据存放在“Oracle数据块”中，而不是“操作系统块”中。通常Oracle数据块是操作系统块的整数倍。Oracle数据块有一定的标准大小，其大小被写入到初始化参数DB_BLOCK_SIZE中。Oracle支持在同一个数据库中使用多种大小的块，与标准块大小不同的块就是非标准块。 数据块中可以存放表数据、索引数据和簇数据等，无论存放哪种类型的数据，其结构都是相同的。数据块由块头、表目录、行目录、空余空间和行数据这5部分组成 块头：存放数据块的基本信息，如块的物理地址、块所属的段的类型。 表目录：存放表的相关信息。如果数据块中存储的数据是表数据，则表目录中存储有关这些表的相关信息。 行目录：如果块中有行数据存在，则这些行的信息将被记录在行目录中。这些信息包括行的地址等。 空余空间：空余空间是一个块中未使用的区域，这片区域用于新行的插入和已经存在的行的更新。 行数据：用于存放表数据和索引数据的地方，这部分空间已被数据行所占用（如表中的若干行数据记录）。 数据区 数据区（Extent也可称作数据扩展区）是由一组连续的Oracle数据块所构成的Oracle存储结构，一个或多个数据块组成一个数据区，一个或多个数据区再组成一个段（Segment）。使用数据区的目的是用来保存特定数据类型的数据，数据区是Oracle存储分配的最小单位，Oracle就以数据区为单位进行存储空间的扩展。当一个段中的所有空间被使用完后，Oracle系统将自动为该段分配一个新的数据区。一个Oracle对象至少包含一个数据区。设置一个表或索引的存储参数包含设置它的数据区大小。 段 段（Segment）是由一个或多个数据区构成，它不是存储空间的分配单位，而是一个独立的逻辑存储结构，是为特定的数据对象（如表、索引、回滚等）分配的一系列数据区。段内包含的数据区可以不连续，并且可以跨越多个文件，使用段的目的是用来保存特定对象，Oracle也把这种占用空间的数据对象统一称为段。一个段只属于一个特定的数据对象，每当创建一个具有独立段的数据对象时，Oracle将为它创建一个段。 数据段：数据段中保存的是表中的数据记录。当创建一个表时，系统自动创建一个以该表的名字命名的数据段。 索引段：索引段中包含了用于提高系统性能的索引。一旦建立索引，系统自动创建一个以该索引的名字命名的索引段。 回滚段：回滚段（也可称作撤销段）中保存了回滚条目，Oracle将修改前的旧值保存在回滚条目中。利用这些信息，可以撤销未提交的操作，以便为数据库提供读入一致性和回滚未提交的事务，即用来回滚事务的数据空间。当一个事务开始处理时，系统为之分配回滚段，回滚段可以动态创建和撤销。Oracle 11g系统有个默认的回滚段，其管理方式既可以是自动的，也可以是手工的。 临时段：当执行创建索引、查询等操作时，Oracle可能会使用一些临时存储空间，用于暂时性地保存解析过的查询语句以及在排序过程中产生的临时数据。Oracle系统将在专门用于存储临时数据的表空间中为操作分配临时段。 在执行CREATE INDEX、SELECT ORDER BY、SELECT DISTINCT和SELECT GROUP BY等几种类型的SQL语句时，Oracle系统就会在临时表空间中为这些语句的操作分配一个临时段。在数据库管理过程中，若经常需要执行上面这类SQL语句，最好调整SORT_AREA_SIZE初始化参数来增大排序区，从而使排序操作尽量能够在内存中完成，以获得更好的执行效率，但同时这对数据库服务器的内存空间提出了更大的要求。 表空间 表空间是数据库的最大逻辑划分区域，通常用来存放数据表、索引、回滚段等数据对象（即Segment），任何数据对象在创建时都必须被指定存储在某个表空间中。表空间（属逻辑存储结构）与数据文件（属物理存储结构）相对应，一个表空间由一个或多个数据文件组成，一个数据文件只属于一个表空间；Oracle数据的存储空间在逻辑上表现为表空间，而在物理上表现为数据文件。 每个数据库至少有一个表空间（即SYSTEM表空间），表空间的大小等于所有从属于它的数据文件大小的总和。由于表空间在物理上（即磁盘上）包含操作系统中的一个或多个数据文件，因此在表空间中创建的数据对象就存在以下两种情况。 若表空间只包含一个数据文件，则该表空间中的所有对象都存储在这个数据文件中。 若表空间包含多个数据文件，则Oracle即可将数据对象存储在该表空间的任意一个数据文件中，也可以将同一个数据对象中的数据分布在表空间的多个数据文件中。 在创建数据库时，Oracle系统会自动创建多个默认的表空间，这些表空间除了用于管理用户数据的表空间之外，还包括用于管理Oracle系统内部数据（如数据字典）的表空间，下面列举了Oracle 11g版本默认创建的主要表空间。 SYSTEM表空间——系统表空间。它用于存放Oracle系统内部表和数据字典的数据，如表名、列名、用户名等。Oracle本身不赞成将用户创建的表、索引等存放在系统表空间中。表空间中的数据文件个数不是固定不变的，可以根据需要向表空间中追加新的数据文件。 SYSAUX表空间。它是Oracle 11g新增加的表空间，是随着数据库的创建而创建的，它充当SYSTEM的辅助表空间，降低了SYSTEM表空间的负荷，主要存储除数据字典以外的其他数据对象。SYSAUX表空间一般不存储用户的数据，由Oracle系统内部自动维护。 UODO表空间——撤销表空间。它用于存储撤销信息的表空间。当用户对数据表进行修改操作（包括插入、更新、删除等操作）时，Oracle系统自动使用撤销表空间来临时存放修改前的旧数据。当所做的修改操作完成并执行提交命令后，Oracle根据系统设置的保留时间长度来决定何时释放掉撤销表空间的部分空间。一般在创建Oracle实例后，Oracle系统自动创建一个名字为UNDOTBS1的撤销表空间，该撤销表空间对应的数据文件是UNDOTBS01.DBF。 USERS表空间——用户表空间。它是Oracle建议用户使用的表空间，可以在这个表空间上创建各种数据对象。例如，创建表、索引、用户等数据对象。Oracle系统的样例用户scott对象就存放在USERS表空间中。 除了Oracle系统默认创建的表空间外，用户可根据应用系统的实际情况及其所要存放的对象类型创建多个自定义的表空间，以区分用户数据与系统数据。此外，不同应用系统的数据应存放在不同的表空间上，而不同表空间的文件应存放在不同的盘上，从而减少I/O冲突，提高应用系统的操作性能。 物理存储结构 Oracle数据库的物理存储结构由多种物理文件组成，主要有数据文件、控制文件、重做日志文件、归档日志文件、参数文件、密码文件和警告日志文件等。 数据文件 用于保存用户应用程序数据和Oracle系统内部数据的文件，创建表空间的同时会创建数据文件。一个数据文件只能属于一个表空间。 在表空间创建对象时，存储的数据文件由Oracle系统选择，一个数据对象的数据可以全部存储在一格数据文件中，也可以分布存储在同一个表空间的多个数据文件中。 读取数据时，先从数据文件读入高速数据缓冲区。若读取的数据不在缓冲区，需要读入并存储在缓冲区。修改和插入数据时，不会立即写入数据文件，而是保存在缓冲区内，由后台进程DBWR决定如何写入数据文件，减少了磁盘I/O操作。 数据文件有3种类型： 系统数据文件：属于系统表空间，存放特殊的用户数据和Oracle系统本身的数据。 撤销数据文件：属于撤销表空间，修改数据使用撤销段(位于撤销表空间)临时存放修改前的旧数据。 用户数据文件：用于存放用户应用系统数据，包括与应用系统有关的所有信息。 Oracle 9i之后，Oracle将临时表空间对应的临时数据文件与一般数据文件分开。 控制文件 控制文件是一个二进制文件，记录数据库的物理结构，主要包括数据库名、数据文件和日志文件的名字和位置、数据库建立日期等信息。系统运行过程中，还存放有系统更改好、检查点信息及归档的当前状态等信息。控制文件一般在Oracle系统安装或创建数据库时自动创建，出于安全考虑，系统会自动创建2个或3个控制文件，记录相同的信息。 Oracle实例启动必须访问控制文件，若控制文件记录了错误信息或找不到可用控制文件，实例无法正常启动。 Oracle实例正常启动时，首先访问初始化参数文件SPFILE，然后Oracle为SGA分配内存。这时Oracle实例处于安装状态，并且控制文件处于打开状态，接下来自动读出控制文件中所有数据文件和日志文件信息，并打开当前数据库中所有的数据文件和日志文件供用户访问。 每个数据库至少有一个控制文件，一个数据库可同时拥有多个控制文件，一个控制文件只能属于一个数据库。数据库物理组成更改时，Oracle自动更新控制文件，数据恢复时，也需要控制文件。 日志文件 记录对数据库所做的修改，对数据库所做的修改几乎都记录在日志文件中。出现问题时，可以通过日志文件得到原始数据。每个Oracle实例都启动一个日志线程记录数据库变化，日志线程由若干日志组构成，每个日志组有一个或多个日志文件。 运行过程中产生的日志信息，首先临时存放在SGA的重做日志缓冲区中，发出COMMIT命令或日志缓冲区信息满1/3时，LGWR将日志信息从缓冲区读取出来，写入日志文件组编号较小的文件里，一个日志组写满后接着写另一个日志组。所有日志文件使用一遍后，再次转向第一个日志组重新覆写。 重做日志文件：记录数据库所有发生过的更改信息及由Oracle内部行为而引起的数据库变化信息，数据库恢复时，可以日志文件读取原始记录。数据库运行期间，执行COMMIT时，数据库首先将原始记录写入日志文件，成功后才将新的记录传递给应用程序。 归档日志文件：日志覆写会导致较早日志信息被覆盖，开启归档模式，会在各个日志文件都被写满而即将覆盖之前，由ARCH将即将被覆盖的日志文件中的日志信息读取写入归档日志文件。LGWR需要等待ARCH结束才能开始覆写文件，延迟系统响应，同时占用大量磁盘空间，默认不启用归档模式。 服务器参数文件 SPFILE是二进制文件，记录Oracle数据库的基本参数信息。在安装数据库系统时由系统自动创建，参数由Oracle系统自动维护，若有修改参数，尽可能避免对文件直接编辑，使用OEM或ALTER SYSTEM。 密码文件 验证sysdba权限的二进制文件，远程用户以sysdba或sysoper连接到数据库时，一般要用密码文件验证。 警告文件 记录Oracle系统的运行信息（实例的启动与关闭、建立表空间、增加数据文件等）和错误信息（空间扩展失败、启动实例失败等）。警告文件会越来越大，应该定期删除。 跟踪文件 后台进程跟踪文件：记录后台进程的警告或错误信息。 用户进程跟踪文件：记录与用户进程相关信息，主要用于跟做SQL语句。 Oracle 11g服务器结构 Oracle服务器主要由实例、数据库、程序全局区和前台进程组成。实例提供管理数据库的功能，数据库用来存储系统数据。实例可划分为SGA和后台进程两部分，SGA使用操作系统的内存资源，后台进程需要使用CPU与内存资源。PGA是一个非共享的内存区域，用于管理用户进程的私有资源。前台进程可以划分为用户进程和服务器进程，需要使用CPU和内存资源。 系统全局区（SGA） SGA是所有用户进程共享的一块内存区域。主要由高速数据缓冲区、重做日志缓冲区、共享池、大型池和Java池等内存结构组成。SGA随数据库实例启动加载到内存中，实例关闭时，SGA区域也消失。 高速数据缓冲区：存放最近访问过的数据块，若访问数据不在缓冲区，先从数据文件读入缓冲区再从缓冲区将数据返回。经常或最近访问的数据块被放置到缓冲区前端，不常访问的放置到后端，缓冲区被填满是，自动挤掉不常访问的数据块。缓冲区分为3个部分。 脏数据区：存放已被修改过的数据，这些数据等待被写入数据文件。 空闲区：不包含任何数据，可以被写入数据。 保留区：包含正在被用户访问的数据块和明确保留以作为将来使用的数据块，被保留在缓冲区。 重做日志缓冲区：存放对数据块进行修改操作时产生的日志信息，写入重做日志文件前，先存放在缓冲区，在检查点发生或缓冲区数据达到一定值时，写入重做日志文件。重做日志缓冲区的大小对数据库性能的影响较小，通常较大的重做日志缓冲区能减少I/O读写次数。 共享池：SGA保留的内存区域，用于缓存SQL语句、PL/SQL语句、数据字典、资源锁、字符集和其他控制结构。包括库高速缓冲区和字典高速缓冲区。 库高速缓冲区：主要包括共享SQL区和私有SQL区。存放最近用过的SQL语句、PL/SQL语句的文本和执行计划，下次执行相同语句时，直接使用执行计划。每条被缓存的语句分为两个部分，分别存储在共享SQL区和私有SQL区。共享SQL区存放语法分析结果和执行计划，私有SQL区存放语句中的绑定变量、环境和会话等信息。 字典高速缓冲区：存放Oracle系统内部管理所需要的数据字典信息，如用户名、数据对象和权限等。 大型池：不是必需内存结构，在特殊情况下，实例使用大型池减轻共享池访问压力。 使用恢复管理器进行备份和恢复操作时，大型池作为I/O缓冲区使用。 使用I/O Slave仿真异步I/O功能时，大型池作为I/O缓冲区使用。 执行具有大量排序操作的SQL语句。 使用并行查询时，大型池作为并行查询进程交换信息的地方。 &amp;ndash;若未设置大型池，实例需要使用时，会在共享池或PGA分配缓存空间，影响共享池和PGA的工作效率。&amp;ndash; Java池：提供内存空间给Java虚拟机使用，支持在数据库中运行Java程序包。 流池：在数据库与数据库之间进行信息共享。 程序全局区（PGA） 也称用户进程全局区，内存区在进程私有区而不是共享区。每个Oracle服务器进程只能访问属于自己的那部分PGA资源，各个服务进程的PGA总和即为实例的PGA大小。PGA通常包括私有SQL区和会话区。 私有SQL区：存储变量以及SQL语句运行时的内存结构信息。把私有SQL区与对应的共享SQL区就可获得一条SQL语句的完整缓存数据。私有SQL区可分为静态区和动态区。静态区的信息在会话过程中保持不变，会话关闭时才释放。动态区信息在整个会话过程中不断变化，SQL语句执行完毕释放。 会话区：存放用户的会话信息。如果数据库处于共享服务器连接模式下，会话区位于SGA而不是PGA。 前台进程 前台进程包括用户进程和服务器进程，不属于实例的一部分。 用户进程：能够产生或执行SQL语句的应用程序。 连接：用户进程与实例直接建立的通信渠道。 会话：用户进程与实例建立连接后形成的用户与实例之间的交互方式，一般是用户发出请求，数据库实例为用户返回响应消息的方式。 服务器进程：处理用户会话过程中想数据库实例发出的SQL语句或SQL-PLUS命令，分为专用服务器模式和共享服务器模式。专用模式下，每个用户进程都有一个专用的服务器进程，服务器进程代表用户执行SQL验收，必要时可回传执行结果给用户进程。共享模式下，每个用户不直接与服务器进程连接，而是连接到分派程序，每个分派程序可以同时连接多个用户进程。 后台进程 后台进程是一组运行在Oracle服务器端的后台程序，是Oracle实例的重要组成部分。其中SMON、PMON、DBWR、LGWR、CKPT这5个后台进程必须正常启动，否则将导致数据库实例崩溃。 数据写入进程（DBWR） 主要任务是负责将内存中的脏数据回写到数据文件中。 高速数据缓冲区没有足够空闲数据块存放新数据。 检查点进程启动后，会强制要求DBWR将某些脏数据块写入数据文件。 脏数据块在高速缓冲区中存放超过3秒钟。 &amp;ndash;DBWR进程的数量不应超过系统处理器的数量，多余的无法发挥作用，还会耗费系统资源。&amp;ndash; 检查点进程（CKPT） 检查点进程可以看作一个事件，当发生日志切换（日志写入操作正要从一个日志组切换到另一组时），就会启动检查点进程。 日志写入进程（LGWR） 将重做日志缓冲区的数据写入重做日志文件。&amp;ndash;发生提交命令，缓冲区满1/3，日志信息存放超过3秒钟。&amp;ndash; 归档进程（ARCH） 可选进程，数据库处于归档模式时，该进程才起作用。系统比较繁忙导致LGWR等待ARCH时，可修改参数启动多个归档进程。 系统监控进程（SMON） 在数据库系统启动时执行恢复工作的强制性进程。 进程监控进程（PMON） 监控其他进程的状态，当有进程启动失败时，PMON会清除失败的用户进程，释放资源。 锁进程（LCKN） 可选进程，并行服务器模式下可出现多个锁定进程以利于数据库通信。 恢复进程（RECO） 可选进程，在分布式数据库模式下用于恢复数据不一致。 调度进程（DNNN） 可选进程，在共享服务器模式下使用，可启动多个调度进程。 快照进程（SNPN） 用于处理数据库快照的自动刷新，并通过DBMS_JOB包运行预定的数据库存储过程。 数据字典 Oracle存放关于数据库内部信息的地方，用来描述数据库的内部运行和管理情况。Oracle数据字典名称由前缀和后缀组成，使用_连接。 dba_：包含数据库实例的所有对象。 v$：当前实例的动态视图，包含系统管理和系统优化等所使用的视图。 user_：记录用户的对象信息。 gv_：分布式环境下所有实例的动态视图，包含系统管理和系统优化等所使用的视图。 all_：记录用户的对象信息及被授权访问的对象信息。 常用数据字典 -- 基本数据字典 dba_tablespaces dba_ts_quotas dab_free_cpace dba_segments dba_extents dba_tables dba_tab_columns dba_views dba_synonyms dba_sequences dba_constraints dba_indexs dba_ind_columns dba_triggers dab_source -- 所有用户的存储过程信息 dba_data_files dba_tab_grants/privs dba_objects dba_users -- 常用动态性能视图 v$database v$datafile v$log v$logfile v$archived_log v$archived_dest v$controlfile v$instance v$system_parameter v$sga v$sgastat v$parameter v$lock v$session v$sql v$sqltext v$bgprocess v$process </description>
    </item>
    
    <item>
      <title>Virtualization Vmware_network</title>
      <link>https://supersonnya.github.io/operation/vt/vt-vmware_network/</link>
      <pubDate>Tue, 16 Aug 2022 17:37:36 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/vt/vt-vmware_network/</guid>
      <description>一、虚拟设备概念 VMnet0：用于虚拟桥接网络下的虚拟交换机 VMnet1：用于虚拟Host-Only网络下的虚拟交换机 VMnet8：用于虚拟NAT网络下的虚拟交换机 VMware Network AdepterVMnet1：Host用于与Host-Only虚拟网络进行通信的虚拟网卡 VMware Network Adepter VMnet8：Host用于与NAT虚拟网络进行通信的虚拟网卡 网桥是一个局域网与另一个局域网之间建立连接的桥梁，是扩展网络和通信的手段，在各种传输介质中转发数据信号，扩展网络的距离。VMWare中，虚拟网卡连接到VMnet0虚拟交换机上才会应用虚拟网桥。 虚拟网卡连接到VMnet1或VMnet8虚拟交换机时，自动安装运行虚拟DHCP服务并连接至虚拟交换机。 虚拟NAT服务器，虚拟网卡连接到VMnet8时自动安装运行虚拟NAT服务器，并连接至虚拟交换机。 主机虚拟网卡与相同名称的虚拟交换机相连。 二、三种连接模式 1、桥接 在这种模式下，VMware虚拟出来的操作系统就像是局域网中的一台独立的主机，可以访问网内任何一台机器。需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立的主机系统，那么就可以手工配置它的TCP/IP配置信息，以实现通过局域网的网关或路由器访问互联网。 宿主机物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，可以选择桥接对象，物理网卡和虚拟网卡处于同一个网段，可以互相ping通。 2、HostOnly 在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机，各个虚拟机内部可以互相通信。其实Host-Only网络和NAT网络很相似，不同的地方就是 Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMnet1虚拟网卡来实现的。此时如果想要虚拟机上外网则需要主机联网并且网络共享。 3、NAT 使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，不需要进行任何其他的配置，只需要主机器能访问互联网即可。这种情况下，主机可以ping通虚拟机，虚拟机也能ping通主机。 VMnet8虚拟网卡知识为宿主机和NAT虚拟网络下的虚拟机提供一个接口，卸载虚拟网卡后虚拟机仍可以上网，但宿主机无法再访问VMnet8网段。 宿主机需要同时开启NAT和DHCP服务。 三、总结 共享连接方式和NAT方式，都可以实现虚拟机和主机，虚拟机和互联网通信，NAT方式设置简单，且可以实现同时访问多个物理网卡。桥接方式可实现虚拟机和主机，虚拟机和互联网通信，若虚拟机作为服务器，只有这种方式可行。但需独立的IP给虚拟机，且若物理网卡连接断开，虚拟机与主机也不能连接。host-only方式只实现虚拟机主机通信，一般不单独采用。 完整克隆与链接克隆 链接克隆：与原始虚拟机共享虚拟磁盘，不能脱离原始虚拟机独立运行。克隆所需时间短，节省物理磁盘空间。 完整克隆：不和原始虚拟机共享任何资源，可独立使用。 修改主机名； 修改虚拟网卡MAC地址：随机生成IP，删除相关配置，下次重启时自动刷新； IP地址； KEYS ## 17 - 4A4RR-813DK-M81A9-4U35H-06KND - NZ4RR-FTK5H-H81C1-Q30QH-1V2LA - 4C21U-2KK9Q-M8130-4V2QH-CF810 - MC60H-DWHD5-H80U9-6V85M-8280D - JU090-6039P-08409-8J0QH-2YR7F - 4Y09U-AJK97-089Z0-A3054-83KLA ## Fusion13.0 - 4A4RR-813DK-M81A9-4U35H-06KND - NZ4RR-FTK5H-H81C1-Q30QH-1V2LA - 4C21U-2KK9Q-M8130-4V2QH-CF810 - MC60H-DWHD5-H80U9-6V85M-8280D - JU090-6039P-08409-8J0QH-2YR7F - 4Y09U-AJK97-089Z0-A3054-83KLA ## 16.x - ZF3R0-FHED2-M80TY-8QYGC-NPKYF - Z1ZPR-EDGQN-M1JE9-HYFGX-YPGEX ## 15.</description>
    </item>
    
    <item>
      <title>Vim编辑器</title>
      <link>https://supersonnya.github.io/operation/linux/linux-vim/</link>
      <pubDate>Mon, 15 Aug 2022 15:35:38 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-vim/</guid>
      <description>编辑、保存、退出 ## 编辑一个文件，如果文件不存在，会自动新建 ## 使用不带任何参数的vim命令，在保存的时候需要指定文件名 vim file :e ## 打开另外一个文件，将文件名作为参数 ## 退出 :q :q! # 强制退出，丢弃修改内容 :w filename ## 另存为filename ## 保存并退出 :wq 文本操作 a ## 在当前光标所处位置的右边插入文本 i ## 在当前光标所处位置的左边插入文本 A ## 在当前行的末尾追加文本 I ## 在当前行的开始处插入文本 O ## 在当前行的上面插入一个新行 o ## 在当前行的下面插入一个新行 R ## 覆盖当前光标所在的位置以及后面的若干文本 J ## 将当前光标所在行与下面的一行合并为一行 光标移动 移动光标的时候，可以在命令前加上数字，表示重复多少次移动。
向下、 j、空格 ## 光标向正下方移动 1 行 向上、 k、backspace ## 光标向正上方移动 1 行 向左、h ## 光标向左移动过 1 个字符 向右、l ## 光标向右移动 1 个字符 回车 ## 光标会移动到下 1 行的行首 - ## 光标会移动到上 1 行的行首 G ## 将光标移动到文件最后 1 行的行首 ^ ## 移动光标到行首 $ ## 移动光标到行尾 Gg ## 移动光标到文件头 W ## 移动光标到下一个单词 B ## 移动光标到前一个单词 Ctrl+f ## 向前（朝向文件尾）翻动一页 Ctrl+b ## 向后（朝向文件头）翻动一页 文本复制、粘贴 yy ## 将当前行复制到缓冲区 nyy ## 将当前行以及下面的n行复制到缓冲区，其中n表示一个整数 yw ## 复制从光标当前位置到当前单词词尾的字符 nyw ## n是一个整数，从光标当前位置开始，复制后面的n个单词 y^ ## 从当前光标所处的位置开始，复制到当前行的行首 y$ ## 从当前光标所处的位置开始，复制到当前行的行尾 p ## 将缓冲区中的字符串插入点当前光标所处位置的后面 P ## 将将缓冲区中的字符串插入到当前光标所处位置的前面 删除文本 x ## 删除光标所在的位置的字符 nx ## 删除从光标所在位置开始，后面的n个字符 dd ## 删除光标所处的整个行 ndd ## 删除包括当前行在内的n行 D ## 删除光标所在位置到行尾之间所有的字符 u ## 撤销刚刚执行的操作 U ## 撤销针对当前行的所有操作 Ctrl+R ## 重做被撤销的操作 跳转搜索替换 ## 跳到行号为n的行 :n ## 向下跳n行 :n+ ## 向上跳n行 :n- ## 向前查找字符串 :/string ## 向后查找字符串 :?</description>
    </item>
    
    <item>
      <title>远程登录</title>
      <link>https://supersonnya.github.io/operation/linux/linux-remotelogin/</link>
      <pubDate>Thu, 11 Aug 2022 17:25:05 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-remotelogin/</guid>
      <description>登录Linux服务器 SSH 为什么不使用telnet: telnet使用明文口令，用户口令以明文的形式在网络上传输，任何人都有机会通过网络嗅探工具直接获取口令。Linux已不再包含telnet服务器程序，也不推荐用户使用。
OpenSSH是Linux下最常用的SSH服务器/客户端软件，可通过发行版的安装源安装: apt-get install ssh。 SSH会对用户的身份进行验证，并加密两台主机之间的通信。 ## 登录到远程服务器 ssh -l login_name hostname | IP ## 默认端口为22，-p指定连接的端口 ssh -l login_name -p port hostname | IP ## 要在远程主机上运行X应用程序，应该保证服务器开启X窗口系统 ## 使用带-X参数命令显式启动X转发功能 ssh -X -l login_name hostname | IP VNC VNC用于图形化的远程登录: apt-get install vnc4-common vnc4server。 ## 运行vncserver脚本生成配置文件 vncserver ## 登录远程主机 vncviewer hostname:desktop_id Windows上同样可使用SSH和VNC连接工具连接远程Linux服务器。
登录Windows服务器 VNC 在Windows上安装VNC Server的软件，在Linux上可以通过VNC登录到Windows服务器。
RDP Linux可直接通过RDP协议连接到 Windows服务器。
## 安装命令行登录工具rdesktop ## 连接到Windows服务器 rdesktop -u username ip-address[:port_num] 使用SSH密钥 密钥方案 通过密钥，管理员在多个服务器之间切换时不需要手动输入口令，实现快速切换。</description>
    </item>
    
    <item>
      <title>文件传输工具</title>
      <link>https://supersonnya.github.io/operation/linux/linux-transferfiles/</link>
      <pubDate>Thu, 11 Aug 2022 17:11:10 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-transferfiles/</guid>
      <description>NFS - Linux主机间共享文件 ## 安装NFS文件系统 ### 需指定远程主机名或IP mount hostname:/pathname pathname/ ### 以可读写方式安装文件系统，若服务器不允许外部可写，会自动选择只读安装 mount -o rw hostname:/pathname pathname/ ### 以可读写、硬安装、可中断、后台重试安装请求的方式安装文件系统 mount -o rw,hard,intr,bg ## 查看服务器端导出的目录 showmount -e [hostname | IP] ## 卸载NFS文件系统，卸载时没有其他进程使用 umount pathname/ ### 强制卸载文件系统 umount -f pathname/ ## 启动时自动安装远程文件系统，写入/etc/fstab 10.171.37.1:/srv/nfs_share /home/lewis/share nfs rw,hard,intr,bg 0 0 ### fstab文件中对NFS的配置立即生效 mount -a -t nfs Samba - Linux与Windows间共享文件 ## 列出当前网络上的共享主机列表 smbtree -S ## 连接共享主机 ### -U指定用户名，-b使用广播的方式搜寻整个网络 smbtree -b -U smbuser ## 查询主机对应的IP nmblookup hostname ## Linux下的Samba客户端: smbclient ### 基本语法，不允许匿名用户登录时应使用-U指定用户名 smbclient //servername/sharename [-U username] ### 修改当前本地目录 lcd /pathname ### 下载文件 get filename ### 退出 quit ## 挂载Windows共享目录 ### 不允许匿名用户登录时应使用-o跟上user指定用户名 mount.</description>
    </item>
    
    <item>
      <title>硬盘分区管理</title>
      <link>https://supersonnya.github.io/operation/linux/linux-diskmanager/</link>
      <pubDate>Mon, 08 Aug 2022 22:37:27 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-diskmanager/</guid>
      <description>安装硬盘和分区 使用 fdisk 建立分区表 使用 mkfs 建立文件系统 使用 fsck 检查文件系统 测试分区 创建并激活交换分区 配置 fstab 文件 重新启动系统 如果某个文件系统出了问题，系统将不能正常启动，而是引导进入救援模式。 在这种情况下，用户应该依次按照下面这些步骤来手动解决问题。 提供 root 口令，以 root 身份登录系统。 使用 fsck 检查并试图修复受损的文件系统。 如果问题依然存在，运行 mkfs 重新在分区上建立文件系统 不太幸运的话，可能需要使用 fdisk 重新建立分区表。 总是可以通过删除 fstab 文件中对应的配置行（或者给它打上注释符号），来临时解决系统无法正常启动的问题。 高级硬盘管理 独立磁盘冗余阵列：RAID 磁盘阵列，独立磁盘构成的具有冗余能力的阵列，磁盘阵列就是由很多价格较为便宜的磁盘，以硬件或者软件的形式形成一个巨大的磁盘组，利用多个磁盘组、多个磁盘组合在一起，提升整个磁盘系统效能。同时还可以通过减少磁盘容量为代价去增加数据的安全性。 RAID实现方式 硬RAID：使用硬件阵列卡，用专门的RAID控制器将硬盘和电脑连接起来，RAID控制器负责将所有的RAID成员磁盘配置成一个虚拟的RAID磁盘卷。对于操作系统而言，只能识别到由RAID控制器配置后的虚拟磁盘，而无法识别到组成RAID的各个成员盘。这种技术一般由供应商提供，不需要特殊操作。 软RAID：通过操作系统软件去实现，在Linux中可通过mdadm命令实现。 RAID 0 条带式，最早出现的RAID模式。
工作模式：将资料分成多个部分，再将多个部分同时往两块磁盘里写入数据，跟内存的双通道技术相似。
最少需要磁盘数：2块。
支持损坏磁盘数：不支持损坏硬盘。
优点：大大的提高了磁盘的读写速度。
缺点：大大提高了数据的风险性，数据是保存在多个磁盘中，一旦有一块磁盘损坏，就失去了所有的数据。
应用环境：不要求安全，只要求速度。适合大规模并发读取。例如数据库从库，存储从库。
RAID 1 镜像卷。
工作模式：在一个磁盘中写入数据，在另一个磁盘中写入镜像数据。
最少磁盘数：2块。
支持损坏磁盘数：1块。
优点：大大提高了数据的安全性，允许损坏一块磁盘。
缺点：在磁盘利用率低，没有提高读写速度。
应用环境：只要求安全，对速度不要求。适合系统盘和监控服务器。
RAID 5 工作模式：条带化，利用数据的异或运算，在n个磁盘中只要知道n-1个磁盘的数据，就可以计算出第n个磁盘的数据。 最少磁盘数：3块。 支持损坏磁盘数：1块。 优点：技术读取速度和Raid 0差不多，多了奇偶校验，写入速度比单个磁盘稍慢。通过运算的方式解决一块硬盘损坏的情况，最多损坏一块硬盘。 应用环境：适合对性能和安全有一定要求但又不太十分高的情况。例如普遍数据库和存储库。 RAID 10 工作模式：RAID0和RAID1技术的结合。将磁盘均分为两部分，对于这两部分使用RAID0。在这两部分内部中，又细分两个部分，对细分的两个部分，使用RAID1。 最少磁盘数：4块。 支持损坏磁盘数：总数的一半。 优点：提高读写速度同时保证数据的安全性。 缺点：损失一半的磁盘空间，磁盘利用率低。 应用环境：对于性能和安全都要求的情况。例如高并发或高访问量数据库主库，存储主库。 # 软RAID10 # 创建磁盘阵列 mdadm -C -v /dev/md10 -l 10 -n 4 /dev/sd{m,n,o,p}。 # 配置文件命令 mdadm -Dsv &amp;gt; /etc/mdadm.</description>
    </item>
    
    <item>
      <title>压缩存档备份</title>
      <link>https://supersonnya.github.io/operation/linux/linux-compressedarchives/</link>
      <pubDate>Mon, 08 Aug 2022 16:54:10 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-compressedarchives/</guid>
      <description>压缩工具 gzip 压缩后只生成新压缩文件，不保留原文件 # 压缩文件 gzip &amp;lt;filename&amp;gt; # 解压文件，支持的扩展名.gz、.Z、-gz、.z、-z、z gunzip &amp;lt;filename&amp;gt; gzip -d &amp;lt;filename&amp;gt; # 查看压缩效果 gzip -l &amp;lt;filename&amp;gt; # 测试压缩文件的完整性 gzip -tv &amp;lt;filename&amp;gt; bzip2 提供比gzip更高的压缩率，速度比gzip慢 # 压缩文件 bzip2 &amp;lt;filename&amp;gt; # 解压文件，支持的扩展名.bz2、.bz、.tbz2、.tbz、bzip2 bunzip2 &amp;lt;filename&amp;gt; bzip2 -d &amp;lt;filename&amp;gt; # 测试压缩文件的完整性 bzip2 -tv &amp;lt;filename&amp;gt; RAR for linux # 解压文件 rar x xxx.rar 存档工具 tar # 文件打包，不会删除原来的文件，命令选项前的-可省略 ## -c创建归档文件，-v显示命令的执行过程，-f指定归档文件的文件名 ## 最后一个（或者几个）参数指定了需要打包的文件和目录 tar -cvf xxx.tar xxx/ tar -xvf xxx.tar ## -w每次将单个文件加入（或者抽出）归档文件时询问，yn回答 tar -cvwf xxx.tar xxx/ tar -xvwf xxx.</description>
    </item>
    
    <item>
      <title>Linux 软件包管理</title>
      <link>https://supersonnya.github.io/operation/linux/linux-packagemanager/</link>
      <pubDate>Thu, 04 Aug 2022 15:43:20 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-packagemanager/</guid>
      <description>dpkg 管理.deb软件包 ## 安装软件包 ### 安装软件之前会删除旧版本 dpkg [-i | --install] *.deb ## 查看已安装的软件包 ### 查找当前系统中软件版本信息 dpkg -l ### 安装的软件向系统中复制的文件列表 dpkg -S ## 卸载软件包 dpkg [-r | --remove] APT 高级软件包工具，可以自动检测软件依赖问题，下载和安装所有文件 ## 下载和安装软件包 ### 更新当前apt-get缓存中的软件包信息，以保证获得的软件包是最新的 apt-get update ### 下载并安装软件包 apt-get install ### 下载并安装在本系统上已有的软件包的最新版本 apt-get upgrade ### 卸载特定的软件包 apt-get remove ### 下载特定的软件源代码 apt-get source ### 删除所有已下载的包文件 apt-get clean ## 查询软件包信息 ### 搜索软件包列表中特定的软件包 apt-cache search ### 列出特定软件包的依赖关系 apt-cache depends ## 配置apt-get ### 用于下载软件的地址通常称之为安装源，配置文件目录为/etc/apt/sources.list apt-get rpm 管理RPM软件包 ## 安装软件包 ### -v用于显示当前正在执行的工作 ### -h打印一系列的#提示当前的安装进度 rpm -i ## 升级软件包 rpm -U ## 查看已安装的软件包 ### 加上-a列出当前系统上已经安装的所有软件包 rpm -q ## 卸载软件包 ### --test要求模拟删除软件包的全过程，但并不真的执行删除操作 ### -vv要求输出完整的调试信息 rpm -e yum 一个开源、流行的命令行包管理器，和APT拥有相同的功能，自动处理依赖关系并一次安装所有依赖的软件包，管理RPM软件包。 ## yum源配置 vi /etc/yum.</description>
    </item>
    
    <item>
      <title>Linux常用命令</title>
      <link>https://supersonnya.github.io/operation/linux/linux-usefulcommands/</link>
      <pubDate>Thu, 04 Aug 2022 11:00:54 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/linux/linux-usefulcommands/</guid>
      <description>命令 要在命令后加上&amp;amp;，指导程序在后台运行 &amp;gt; | &amp;gt; &amp;gt; &amp;gt;: 把程序的输出写入目标文件，若文件不存在则新建，覆盖原来内容 &amp;gt;&amp;gt;: 把程序的输出追加到目标文件 &amp;lt; | &amp;lt; &amp;lt; &amp;lt;: 输入重定向，让程序从一个文件中获取输入 &amp;lt;&amp;lt;: 立即文档，指定一个代表输入结束的分隔符，遇到这个单词的时候，即认为输入结束，并把键盘输入一起传递给命令 输入重定向和输出重定向可结合在一起使用 | 管道，将一条命令的输出连接到另一条命令输入 cat | more | less cat: 查看文件内容，后跟文件名作为参数 -n: 在每一行前显示行号 more: 一页一页地显示文件内容 空格键向下翻动一页，Enter键向下滚动一行，Q键退出 less: 更好的文本阅读工具 -M: 阅读文件时在底部显示更多的文件信息 空格键向下翻一页；B键向上翻一页；/跟上查找的内容搜索某个字符串，继续查找相同的内容，再次输入/，并按下回车键；Q键退出 cd 改变目录 chgrp 设置文件的属组 -R: 改变一个目录及其下所有文件和子目录的所有权 chmod 改变文件的权限，只有文件的属主和root用户才有权修改文件的权限 用户组包括文件属主u、文件属组g、其他人o和所有人a，权限包括读取r、写入w和执行x 设置权限规则：用户组+/-权限、用户组=权限、用户组1=用户组2 可使用八进制语法设置文件权限 chown [OPTION]&amp;hellip; [OWNER][:[GROUP]] FILE&amp;hellip; 改变文件的所有权，参数OWNER或:GROUP可省略 -R: 改变一个目录及其下所有文件和子目录的所有权 cp -i: 目标目录有同名文件时提示是否覆盖 -b: 在目标目录的同名文件的文件名后加~ -r: 将子目录连同其中的文件一起复制到另一个子目录下 cpu lscpu、top、htop、glances df 查看磁盘使用情况 -t: 用于显示特定的文件系统 dir | vdir dir: 列出目录内容 vdir: 相当于为ls命令加上-l选项 disk fdisk、iotop fdisk 建立分区表 m显示所有可用的命令及其简要介绍 find [OPTION] [path&amp;hellip;] [expression] 在指定范围内查找文件 -name: 指定文件名 -type: 指定文件类型 -print: 表示将结果输出到标准输出 -atime +[-]n: 最近n天[没有]使用过的文件 -mtime +[-]n: 最近n天[没有]修改过的文件 find .</description>
    </item>
    
    <item>
      <title>Regexp基础知识</title>
      <link>https://supersonnya.github.io/operation/tools/tools-regexp/</link>
      <pubDate>Tue, 26 Jul 2022 14:39:54 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/tools/tools-regexp/</guid>
      <description>简介 Regexg是正则表达式Regular Expression的简称，用于匹配、查找和管理文本。正则表达式是表示搜索模式的字符串，常用于查找和替换文本中的字词。 基础使用 基本匹配 直接输入查找的字符或单词，类似搜索 模式匹配 ## BRE \ : 匹配特殊字符 ^ : 加在表达式前，仅查找行首 $ : 匹配字符串的结束 ^$ : 匹配空行 . : 匹配任何字符，包括特殊字符和空格 [abc] : 可选字符匹配 [^abc] ： 否定字符集 [a-z] : 字母范围，包括首尾 [0-9] : 数字范围，包括首尾 * ： 一个字符不出现、出现一次或多次 .* : 匹配所有内容 ^.* : 匹配任意多个字符开头的内容 $.* : 匹配任意多个字符结尾的内容 ## ERE，使用grep -E才能生效 + ： 一个字符出现一次或多次 [:/]+ : 匹配括号内的字符一次或多次 ？ ： 一个字符不出现或出现一次 {n} ： 一个字符出现的确切次数 {n, } ： 一个字符至少出现多少次 {, m} ： 一个字符最多出现多少次 {n, m} : 至少和至多出现的次数 () : 分组 ()-\1 : 引用组 (?</description>
    </item>
    
    <item>
      <title>Scoop安装及使用</title>
      <link>https://supersonnya.github.io/operation/tools/tools-scoop/</link>
      <pubDate>Tue, 26 Jul 2022 11:15:21 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/tools/tools-scoop/</guid>
      <description>Scoop安装 Windows包管理器 Invoke-Expression (New-Object System.Net.WebClient).DownloadString(&amp;#39;https://get.scoop.sh&amp;#39;) iwr -useb get.scoop.sh | iex Set-ExecutionPolicy RemoteSigned -scope CurrentUser Scoop常用命令 scoop search &amp;lt;app_name&amp;gt; scoop install &amp;lt;app_name&amp;gt; scoop uninstall &amp;lt;app_name&amp;gt; scoop list scoop cache rm &amp;lt;app_name&amp;gt; | scoop cache rm * scoop bucket known scoop bucket add &amp;lt;bucket_url&amp;gt; Scoop使用 scoop install -g aria2 # 修改aria配置 scoop config aria2-enabled true # default: true scoop config aria2-retry-wait 8 # default: 2 scoop config aria2-split 8 # default: 5 scoop config aria2-max-connection-per-server 8 # default: 5 scoop config aria2-min-split-size] 2M # default: 5M 安装常用软件 scoop install -g dingtalk scoop install -g git scoop install -g hugo-extended scoop install -g koodo-reader scoop install -g lx-music scoop install -g mobaxterm scoop install -g mysql-workbench scoop install -g neteasemusic scoop install -g potplayer scoop install -g python@3.</description>
    </item>
    
    <item>
      <title>Adb命令</title>
      <link>https://supersonnya.github.io/operation/tools/tools-adbcmds/</link>
      <pubDate>Tue, 26 Jul 2022 09:31:03 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/tools/tools-adbcmds/</guid>
      <description>adb连接Android设备 adb connect &amp;lt;device_ip&amp;gt; # 显示连接设备 adb devices fastboot devices 操作指令 查看应用列表 # 查看所有应用 adb shell pm list packages # 查看系统应用 adb shell pm list packages -s # 查看第三方应用 adb shell pm list packages -3 # 查看禁用应用 adb shell pm list packages -d # 查看启用应用 adb shell pm list packages -e # 查询应用详情 adb shell dumpsys package &amp;lt;package_name&amp;gt; # 查看应用安装路径 adb shell pm path &amp;lt;package_name&amp;gt; # 查看应用安装路径 安装应用 # 普通安装 adb install &amp;lt;apk_path&amp;gt; # 安装到SD存储卡 adb install -s &amp;lt;apk_path&amp;gt; # 覆盖安装 adb install -r &amp;lt;apk_path&amp;gt; # 降级覆盖安装 adb install -d &amp;lt;apk_path&amp;gt; # 允许应用所需全部权限 adb install -g &amp;lt;apk_path&amp;gt; 禁用恢复应用 # 禁用 adb shell pm disable-user &amp;lt;package_name&amp;gt; # 恢复 adb shell pm enable &amp;lt;package_name&amp;gt; # 删除 adb shell pm uninstall [-k] --user 0 &amp;lt;package_name&amp;gt; 强制停止应用 adb shell am force-stop &amp;lt;package_name&amp;gt; 重启系统 # 普通重启 adb reboot # 重启到Recovery模式 adb reboot recovery # 重启到Fastboot模式 adb reboot bootloader 其他 # 切换到Shell模式 adb shell # 电脑文件传送到Android adb push &amp;lt;file_name&amp;gt; /sdcard/ # Android文件下载到电脑 adb pull /sdcard/&amp;lt;filename&amp;gt; &amp;lt;local_path&amp;gt; </description>
    </item>
    
    <item>
      <title>Git基本使用</title>
      <link>https://supersonnya.github.io/operation/tools/tools-git/</link>
      <pubDate>Thu, 21 Jul 2022 17:03:39 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/tools/tools-git/</guid>
      <description>Git本地使用 初始化一个Git仓库：git init 添加文件到Git仓库 将文件添加到暂存区，可多次使用，添加多个文件：git add &amp;lt;file&amp;gt;； 将添加的文件全部提交到仓库的当前分支：git commit -m &amp;lt;message&amp;gt;。 查看仓库当前状态：git status 查看修改的文件内容：git diff 本地仓库管理 HEAD指向当前版本 查看提交历史版本：git log 回退到指定版本：git reset --hard &amp;lt;commit_id&amp;gt; HEAD^表示上一版本，HEAD^^上两个版本，HEAD~100上100版本 查看命令历史，确定回到未来的版本：git reflog 丢弃工作区修改，用版本库或暂存区的文件替换工作区文件：git checkout -- filename 将文件从暂存区取回，替换工作区文件：git reset HEAD filename 删除文件：git rm filename; git commit 恢复误删文件：git checkout -- filename Git远程仓库 添加远程仓库：git remote add &amp;lt;name default origin&amp;gt; &amp;lt;url&amp;gt; 首次推送全部文件：git push -u origin master 后续提交：git push origin master 查看远程仓库信息：git remote -v 删除远程仓库：git remote rm &amp;lt;name&amp;gt; 克隆远程仓库：git clone &amp;lt;git_path&amp;gt; 免输密码推送远程仓库 https方式 url = https://userName:password@github.</description>
    </item>
    
    <item>
      <title>Database Oracle_basical</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_basical/</link>
      <pubDate>Wed, 18 Aug 2021 16:20:08 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_basical/</guid>
      <description>Oracle发展 第6版：引入了行级锁特性，不完善的PL/SQL语言，引入联机热备份功能。 第7版：分布式事务处理功能，增强的管理功能，用于应用程序开发的新工具以及安全方法。 第8版：支持面向对象的开发及新的多媒体应用，开始具有同时处理大量用户和海量数据的特性。为支持Internet、网络计算等奠定了基础。 Oracle 8i：i代表Internet，添加了大量为支持Internet而设计的特性，为数据库用户提供了全方位的Java支持，成为第一个完全整合了本地Java运行时环境的数据库，用Java就可以编写Oracle的存储过程。 Oracle 9i：加入许多新特性，最重要的是Real Application Clusters(RAC)——集群技术。 Oracle 10g：g代表grid，最大的特性是加入了网格计算的功能。 Oracle 11g：最常用的版本，实现了信息生命周期管理等多项创新，大幅地提高了系统性能的安全性，全新的Data to Guard最大化了可用性，利用全新的高级数据压缩技术降低了数据存储的支出，明显缩短了应用程序测试环境部署及分析测试结果所花费的时间，增加了RFIDTag、DICOM医学图像、3D空间等重要数据类型的支持，加强了Binary XML的支持和性能优化。 Oracle 12c：c代表cloud，增加云计算功能，当前最新版本。 关系数据库基本理论 数据库管理技术发展阶段：人工管理、文件系统、数据库系统。 数据库系统的数据模型主要有层次模型、网状模型、关系模型和面向对象模型。目前理论成熟、使用普及的是关系模型。 关系型数据库设计范式 关系型数据库由相互联系的一组关系所组成，每个关系包括关系模式和关系值的两个方面。关系模式是对关系的抽象定义，给出关系的具体结构；关系的值是关系的具体内容，反映关系在某一时刻的状态。每个关系都需要进行规范化，使之达到一定的规范化程度，从而提高数据的结构化、共享性、一致性和可操作性。 规范化是把数据库组织成在保持存储数据完整性的同时最小化冗余数据的结构的过程。规范化的数据库必须符合关系模型的范式。范式可以防止在使用数据库时出现不一致的数据，并防止数据丢失。关系模型范式有第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、第四范式、第五范式、第六范式和BCNF范式等多种。通常数据库满足前3个范式就足够用了。 第一范式 第一范式是对关系模式的基本要求，不满足第一范式的数据库就不是关系型数据库。 第一范式是第二和第三范式的基础，是最基本的范式。包括以下指导原则： 数据组的每个属性只可以包含一个值。 关系中的每个数组必须包含相同数量的值。 关系中的每个数组一定不能相同。 如果数据表中的每一个列都是不可再分割的基本数据项，就称此数据表符合第一范式。第一范式具有不可再分解的原子特性。 第二范式 满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实体（即各个记录行）必须可以被唯一地区分。 第二范式要求实体的属性完全依赖于主关键字，不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一格新的实体，新实体与原实体之间是一对多的关系。 （员工编码，岗位）→（决定）（姓名，年龄，学历，基本工资，绩效工资，奖金）。 第三范式 满足第三范式必须先满足第二范式。第三范式要求关系表不存在非关键字列对任意候选关键字列的传递函数依赖，即第三范式要求一个关系表中不包含已在其他表中包含的非主关键字信息。 传递函数依赖：如果存在关键字段A决定非关键字段B，而非关键字段B决定非关键字段C，则称非关键字段C传递函数依赖于关键字段A。 （员工编码）→（决定）（姓名，年龄，部门编码，部门经理）。 基础 数据库的设计主要是数据库模式的设计 属性之间的关联成为数据依赖：函数依赖、多值依赖、连接依赖 规范化规则并不能帮助建立好的数据模型，只是提供了一直检验建立的数据模型是否正确的测试手段 第一范式-1NF 实体（表）的所有属性都不可分，即不包含多值属性，则满足1NF 两种方法实现非1NF的结构：数组引用和嵌套表 第二范式-2NF 函数依赖不是根据一个值导出另一个值，而是对于一个值来说，另一个值是逻辑上唯一的 不存在依赖于部分主码的属性 students_grade(student_id, course_id, grade, age) 第三范式-3NF 不能存在传递函数依赖关系 存在一个属性，它所函数依赖的属性既不是主码也不是候选码 BC范式-BCNF 消除主属性对码的部分和传递依赖 Oracle 11g新功能 增强信息生命周期管理和存储管理能力 Oracle 11g具有极新的数据划分和压缩功能，可实现更经济的信息生命周期管理和存储管理。实现了很多手工数据划分工作的自动化，扩展了已有的范围、散列和列表划分功能，增加了间隔、索引和虚拟卷划分功能。 全面回忆数据变化 Oracle 11g具有Oracle全面回忆（Oracle Total Recall）组件，可帮助管理员查询在过去某些时刻指定表格中的数据， 最大限度提高信息可用性 Oracle闪回交易（Oracle Flashback Transaction），可以轻松撤销错误交易以及任何相关交易；并行备份和恢复功能，可改善非常大数据库的备份和存储性能；“热修补”功能，不必关闭数据可就可以进行数据库修补，提高系统可用性。 Oracle快速文件 存储大型对象，包括图像、大型文本对象或一些先进的数据类型，如XML、医疗成像数据和三维对象。Oracle快速文件（Oracle Fast Files）组件使得数据库的性能完全比得上文件系统的性能。 更快的XML Oracle 11g增加了对二进制XML数据的支持，客户可以选择适合自己特定应用及性能需求的XML存储选项。 透明的加密 将透明数据加密功能扩展到卷级加密之外，具有表空间加密功能，可用来加密整个表、索引和所存储的其他数据。 嵌入式OLAP行列 OLAP行列在数据库中可以像物化图一样使用，受益于OLAP高性能的同时，开发人员可以用标准SQL实现数据查询。 连接汇合和查询结果高速缓存 增加了查询结果高速缓存等新功能。通过高速缓存和重用经常调用的数据库查询以及数据库和应用层的功能，改善应用的性能和可扩展性。 增强应用开发能力 Oracle 11g提供多种开发工具，提供的简化应用开发流程可以充分利用Oracle 11g的关键功能，这些关键功能包括客户端高速缓存、提供应用速度的二进制XML、XML处理以及文件存储和检索。 Oracle 11g管理工具 SQL*PLUS 连接语法格式：SQLPLUS username[/password][@connect_identifier] [AS SYSOPER|SYSDBA]。 关键字不区分大小写，但参数区分大小写。 Oracle企业管理器(Oracle Enterprise Manager) URL：https://localhost:1158/em。 数据库配置助手(Database Configuration Assistant, DBCA) 创建和配置数据库。 启动和关闭数据库实例 启动数据库实例 Oracle数据库实例启动过程：启动实例、加载数据库、打开数据库。 启动数据库命令格式：STARTUP [NOMOUNT | MOUNT | OPEN | FORCE] [RESCRICT] [PFILE=filename] NOMOUNT：启动实例，不加载数据库。 通常在创建新数据库或重建控制文件时使用。 MOUNT：启动实例，加载数据库，不打开数据库。 通常在进行数据库维护时使用，比如执行数据库完全恢复操作、更改数据库的归档模式等。 OPEN：启动实例，加载数据库，打开数据库，默认选项。 FORCE：终止实例并重新启动数据库，具有一定的强制性。 RESTRICT：指定以受限制的会话方式启动数据库。 PFILE：指定启动实例时使用的文本参数文件，filename为文件名。 实例启动时必须读取一个初始化参数文件以获取有关参数配置信息。 关闭数据库实例 Oracle关闭数据库实例过程：关闭数据库、卸载数据库、关闭实例。 关闭数据库语法格式：SHUTDOWN [NORMAL | TRANSACTIONAL | IMMEDIATE | ABORT]。 NORMAL：以正常方式关闭数据库。 对关闭数据库时间没有限制时，通常使用这种方式关闭。 阻止任何用户建立新连接；等待当前所有正在连接的用户主动断开连接；所有用户断开连接后立即关闭数据库。 TRANSACTIONAL：在当前所有的活动事务被提交完毕之后，关闭数据库。 阻止用户建立新连接和开始新事务；等待所有活动事务提交后，断开用户连接；所有事务提交完毕、所有用户断开连接后，关闭数据库。 IMMEDIATE：在尽可能短的时间内立即关闭数据库。 阻止用户建立新连接和开始新事务；将未提交的活动事务回退；关闭数据库。 ABORT：以终止方式关闭数据库，具有一定的强制性和破坏性，可能丢失数据信息，影响数据库的完整性。 阻止用户建立新连接和开始新事务；取消未提交的活动事务，不是回退；立即终止正在执行的任何SQL语句；立即关闭数据库。 </description>
    </item>
    
    <item>
      <title>ChartJS介绍及基础使用</title>
      <link>https://supersonnya.github.io/operation/tools/tools-chartjs/</link>
      <pubDate>Sun, 09 Aug 2020 14:10:02 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/tools/tools-chartjs/</guid>
      <description>介绍 chartjs 是可以画各种图表的一款前端工具 chart.min.js 基于 ctx Chart对象，并传递如下参数进去 type: &amp;#39;line&amp;#39; 表示这个是一个线型图表。 bar表示柱状图。 data: 提供要显示的数据 labels 表示数据下方的文字。 datasets 表示数据集合。 一组数据一条线。 label: 这组数据的名称 data: 具体数据 borderColor: 线条颜色 borderWidth: 线条宽度 fill: false. 不进行填充 options: 其他选项 tooltips 表示鼠标移动到图标的时候的提示信息。 intersect: false. 表示鼠标不放在数据点上时，也会显示提示信息。 model: &amp;#39;index&amp;#39; 显示模式 var ctx = document.getElementById(&amp;#39;myChart&amp;#39;).getContext(&amp;#39;2d&amp;#39;); var myChart = new Chart(ctx, { type: &amp;#39;line&amp;#39;, data: { labels: [&amp;#39;红&amp;#39;, &amp;#39;蓝&amp;#39;, &amp;#39;黄&amp;#39;, &amp;#39;绿&amp;#39;, &amp;#39;紫&amp;#39;, &amp;#39;橙&amp;#39;], datasets: [{ label: &amp;#39;示例&amp;#39;, data: [12, 19, 3, 5, 2, 3], borderColor:&amp;#39;blue&amp;#39;, borderWidth: 1, fill: false, }] }, options: { tooltips: { intersect: false, mode: &amp;#39;index&amp;#39; } } }); 柱状图 &amp;lt;script&amp;gt; var ctx = document.</description>
    </item>
    
    <item>
      <title>Docker安装及使用</title>
      <link>https://supersonnya.github.io/operation/vt/vt-container_docker_install_use/</link>
      <pubDate>Sun, 09 Aug 2020 14:10:02 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/vt/vt-container_docker_install_use/</guid>
      <description>安装Docker # install docker yum insatall docker-io # start docker systemctl start docker # check if installed successfully ps -ef|grep docker # restart docker systemctl restart docker # stop docker systemctl stop docker Docker安装Mysql # install mysql in docker ## search mysql docker search mysql ## instal mysql docker pull mysql ## check images docker images ## build directory cd /opt/ mkdir mysql_docker cd mysql_docker/ echo $PWD # start mysql docker run --name mysqlserver -v $PWD/conf:/etc/mysql/conf.</description>
    </item>
    
    <item>
      <title>MySQL基础</title>
      <link>https://supersonnya.github.io/operation/database/mysql/database-mysql/</link>
      <pubDate>Sun, 09 Aug 2020 14:10:02 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/mysql/database-mysql/</guid>
      <description>基本操作 操作表 SHOW CREATE TABLE 表名：查看指定表的创建语句 DESC 表名：查看表结构 ALTER TABLE 表名 MODIFY 列名 列类型：修改列类型 ALTER TABLE 表名 CHANGE 原列名 新列名 列类型：修改列名 ALTER TABLE 原表名 RENAME TO 新表名：修改表名称 删除表 TRUNCATE：先删除表和数据，再按照表结构重建表 DCL 一个项目创建一个用户，一个项目对应的数据库只有一个 用户只对这个数据库有权限 创建用户 CREATE USER 用户名@IP IDENTIFIED BY &amp;lsquo;PASSWORD&amp;rsquo; CREATE USER 用户名@&amp;rsquo;%&amp;rsquo; IDENTIFIED BY &amp;lsquo;PASSWORD&amp;rsquo; 查看权限 SHOW GRANTS FOR 用户名@IP 删除用户 DROP USER 用户名@IP 排序 ORDER BY：后面对多列排序，依次筛选，前面列相同时才进行后面的排序 聚合函数 COUNT() SUM() MAX() MIN() AVG() 分组 分组时查询的列除了主信息，只能是聚合函数，否则导致逻辑错误 WHERE 是分组前的筛选，HAVING 是分组后的筛选 LIMIT 方言 SELECT * FROM tableName LIMIT 4, 3;从第5行开始，查询三行 约束 约束是添加在列之上的，用来约束列 1.</description>
    </item>
    
    <item>
      <title>Docker基础命令</title>
      <link>https://supersonnya.github.io/operation/vt/vt-container_dokcer_basicalcmds/</link>
      <pubDate>Sun, 09 Aug 2020 13:15:42 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/vt/vt-container_dokcer_basicalcmds/</guid>
      <description>Docker 信息 sudo docker version：查看Docker版本信息。 sudo docker info：显示Docker Engine的相关信息。 容器生命周期 start/stop/restart # 启动一个或多个已经被停止的容器 docker start [OPTIONS] CONTAINER [CONTAINER...] # 停止一个运行中的容器 docker stop [OPTIONS] CONTAINER [CONTAINER...] # 重启容器 docker restart [OPTIONS] CONTAINER [CONTAINER...] rm # 删除一个或多个容器 docker rm [OPTIONS] CONTAINER [CONTAINER...] exec # 在运行的容器中执行命令 docker exec [OPTIONS] CONTAINER COMMAND [ARG...] docker exec -it container_id /bin/bash 容器操作 ps # 列出容器 docker ps [OPTIONS] 镜像仓库 login # 登陆Docker镜像仓库，默认为官方仓库 Docker Hub docker login -u username -p pwd # 登出Docker镜像仓库，默认为官方仓库 Docker Hub docker logout pull # 从镜像仓库中拉取或更新指定镜像 docker pull [OPTIONS] NAME[:TAG|@DIGEST] push # 本地镜像上传到镜像仓库 docker push [OPTIONS] NAME[:TAG] search # 从Docker hub查找镜像 docker search [OPTIONS] term 本地镜像管理 image # 列出本地镜像 docker images rmi # 删除本地镜像 docker rmi [OPTIONS] IMAGE [IMAGE.</description>
    </item>
    
    <item>
      <title>Hugo Post Format</title>
      <link>https://supersonnya.github.io/operation/tools/tools-hugo_postformat/</link>
      <pubDate>Sun, 21 Jun 2020 09:51:43 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/tools/tools-hugo_postformat/</guid>
      <description>1. title属性 series - keywords 2. 标题 从三级标题展开，每个三级标题块换行 标题使用阿拉伯数字，标题序号后空格隔开，子标题加上序号 3. 代码 代码段标注代码语言 4. 新建指定类型文件 hugo new --kind post path\name.md。 </description>
    </item>
    
    <item>
      <title>Markdown基础语法</title>
      <link>https://supersonnya.github.io/operation/tools/tools-markdown_basicalgrammer/</link>
      <pubDate>Sat, 20 Jun 2020 09:56:18 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/tools/tools-markdown_basicalgrammer/</guid>
      <description>1. 标题 1.1 使用=和-标记一级和二级标题 一级标题 ======= 二级标题 ------- 1.2 使用#标记 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 2. 段落 使用两个以上空格加上换行来开始下一个段落 直接使用一个空行表示开始一个段落 3. 字体 可以使用*或_ *斜体* **粗体** ***粗斜体*** 4. 线条效果 4.1 分割线 可以使用三个以上*、-或_ *** * * * --- - - - ___ _ _ _ 4.2 删除线 使用两个~ ~~删除线~~ 4.3 下划线 使用&amp;lt;u&amp;gt;&amp;lt;/u&amp;gt; &amp;lt;u&amp;gt;下划线&amp;lt;/u&amp;gt; 4.4 脚注 脚注[^foot] [^foot]: 添加脚注 5. 列表 5.1 无序列表 使用*、+或-加空格 * 第一项 + 第二项 - 第三项 5.</description>
    </item>
    
  </channel>
</rss>
