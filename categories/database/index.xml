<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>database on Sonnya</title>
    <link>https://supersonnya.github.io/categories/database/</link>
    <description>Recent content in database on Sonnya</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 09 Dec 2022 16:43:38 +0800</lastBuildDate><atom:link href="https://supersonnya.github.io/categories/database/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Database Redis</title>
      <link>https://supersonnya.github.io/operation/database/redis/database-redis/</link>
      <pubDate>Fri, 09 Dec 2022 16:43:38 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/redis/database-redis/</guid>
      <description>NoSQL数据库 Web发展历史 Web1.0：以门户网站为代表，主要以用户阅读、浏览为主，没有太大性能问题。 Web2.0：用户参与，网站和数据库压力越来越大。 数据库性能瓶颈：单机数据库的性能有限，需要使用Redis作为缓存数据块，解决高并发问题缓解数据库的压力。 NoSQL数据库 非关系型数据库或Not Only SQL，不保证ACID特性。 特点：非关系型；没有模式，可存储结构化、非结构化或半结构化数据；速度快；支持海量数据存储。 应用场景：高并发读写、海量数据读写、高可扩展、速度快。 不适用场景：事务支持、结构化查询。 NoSQL数据库：memcache、Redis、mongoDB。 NewSQL：基于NoSQL又可支持SQL操作，例如HBase。 Redis介绍 基本介绍 开源的、使用ANSI、C语言编写的key-value数据库。 与Memcache类似，数据缓存在计算机内存中。 应用场景 取出最新N个数据。 排行榜应用，取出TOP N操作。 需要精准设定过期时间的应用，例如短信验证码。 计数器应用。 获取某段时间所有数据去重值。 实时系统，反垃圾系统，用于存储一些规则。 缓存，数据之间存放在内存中。 特点 高效性：高速读写。 原子性：所有操作都是原子性的。 支持多种数据结构：字符串、列表、集合、哈希、有序集合。 稳定性：持久化、主从复制集群。 其他特性：过期时间、事务、消息订阅。 Redis安装 ## 获取安装包redis.tar.gz ## 解压安装包 tar -zxvf redis.tar.gz ## 安装C程序运行环境 yum install gcc-c++ -y ## 安装新版本tcl，控制Linux中命令的执行流程 yum install tcl -y ## 编译redis make make test &amp;amp;&amp;amp; make install ## 修改redis配置文件 mkdir -p ./redis-x.x.x/log mkdir -p ./redis-x.x.x/data vi redis.</description>
    </item>
    
    <item>
      <title>Database Oracle_tablespaceanddatafile</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_tablespaceanddatafile/</link>
      <pubDate>Thu, 18 Aug 2022 16:29:00 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_tablespaceanddatafile/</guid>
      <description>表空间和数据文件的关系 一个数据库包含多个表空间，每个表空间包含一个或多个数据文件。创建表空间时必须创建数据文件，增加数据文件时必须指定表空间。一个段只能驻留在一个表空间内，段的下一层是盘区，一个或多个盘区组成一个段，每个盘区只能驻留在一个数据文件中，若一个段跨越多个数据文件，就只能由多个驻留在不同数据文件中的盘区构成。盘区的下一层是数据块，是磁盘空间管理中逻辑划分的最底层，一组连续的数据块组成一个盘区。 -- 表空间和对应数据文件的关系从dba_data_files数据字典中查询 select tablespace, file_name, bytes from dba_data_files; Oracle 11g的默认表空间 默认表空间是在创建数据库时，系统自动创建的表空间，用于存放Oracle系统内部数据和提供样例所需要的逻辑空间。 -- 安装时选择实例方案，存放个样例的数据 EXAMPLE -- 存放数据字典，包括表、视图、存储过程的定义等 SYSTEM -- SYSTEM的辅助空间，存放一些选件的对象，减少SYSTEM表空间的负荷 -- 可以增加数据文件和监视等操作，但不能执行删除、重命名或设置只读等操作 SYSAUX -- 存放SQL语句处理的表和索引的信息，如数据排序 TEMP -- 存放撤销数据 UNDOTBA1 -- 存放应用系统所使用的数据库对象 USERS 创建表空间 为简化表空间管理并提高系统性能，Oracle建议将不同类型的数据对象存放到不同的表空间中。在创建数据库之后，还应根据具体应用建立不同类型的表空间。 创建小文件表空间还是大文件表空间，默认小文件。 使用局部盘区管理方式，还是使用传统目录盘区管理方式，默认局部盘区管理。 手工管理段空间，还是自动管理，默认自动管理。 是否使用临时段或撤销段的特殊表空间。 创建表空间语法 CREATE [SMALLFILE|BIGFILE] TABLESPACE tablespace_name DATAFILE &amp;#39;/path/filename&amp;#39; SIZE num [k|m] REUSE -- reuse表示若文件存在，吃；出该文件再重建建立 [, &amp;#39;/path/filename&amp;#39; SIZE num [k|m] REUSE] [, ...] [AUTOEXTEND [ON|OFF] NEXT num[k|m] -- 若自动扩展，需要设置next值 [MAXSIZE [UNLIMITED | num[k|m]]]] -- 自动扩展的最大值 [MININUM EXTENT num [k|m]] -- 指定最小长度，由操作系统和数据库块决定 [DEFAULT STORAGE storage] -- 指定以后要创建的表、索引及簇的存储参数值 [ONLINE | OFFLINE] -- 创建表空间可指定在线或离线 [LOGGING | NOLOGGING] -- 加载表空间内表的时候是否产生日志，默认产生日志 [PERMANENT | TEMPORARY] -- 永久表空间还是临时表空间，默认为永久表空间 [EXTENT MANAGEMENT DICTIONARY | LOCAL -- 表空间的扩展方式使用数据字典管理还是本地化管理，默认本地化 [AUTOALLOCATE | UNIFORM SIZE num[k|m]]] -- 若采用本地化管理，扩展时指定每次盘区扩展大小是系统自动指定还是按照等同大小进行，若按照等同大小，默认每次扩展大小为1mb 通过本地化管理方式创建表空间 本地化表空间管理使用位图跟踪表空间对应的数据文件的自由空间和块的使用状态，位图中每个单元对应一个块或一组块。当分配或释放一个扩展时，Oracle会改变位图的值以指示该块的状态。位图值得改变不会产生回滚信息。本地管理表空间有以下优点： 使用本地化得扩展管理功能可以避免发生重复的空间管理操作。 本地化管理的自动扩展能够跟踪临近的自由空间，可以消除结合自由空间的麻烦。 通过段空间管理方式创建表空间 段空间管理方式是建立在本地化空间管理方式基础之上的，只有本地化管理方式的表空间，才能在其基础上进一步建立段空间管理方式。段空间管理又分为手工段和自动段两种方式。 SEGMENT SPACE MANAGEMENT MANUAL/AUTO 手工段空间管理方式 手工段空间管理方式是为了向后兼容而保留，使用自由块列表和PCT_FREE和PCT_USED参数来标识可供插入操作使用的数据块。 每个INSERT或UPDATE操作后，比较数据块中剩余自由空间和PCT_FREE设置，小于则从自由块列表移除。 每个UPDATE或DELETE操作后，比较数据块中已用空间和PCT_USED设置，小于则加入自由块列表。 自动段空间管理方式 使用位图标识可用于插入操作的数据块，及需要从自由块列表取下的数据块。PCT_FREE和PCT_USED参数会被自动忽略，比手工段空间管理方式具有更好的性能，是创建表空间时的首选方式。 自动段空间不能用于创建临时表空间和系统表空间。 默认情况是手工管理方式，创建表空间时需明确指定AUTO。 创建非标准块表空间 通常块大小为8kb，允许创建大小与基本块不同的表空间，块大小由创建表空间时的BLOCKSIZE指定，有利于存储不同大小的对象。 非标准块的大小为基本块的倍数。 块较大的表空间通常用来存放大对象（LOB）类型。 Oracle 11通常使用SGA自动共享内存管理，需要设置初始化参数DB_16K_CACHE_SIZE=16K。 维护表空间和数据文件 管理撤销表空间 管理临时表空间 </description>
    </item>
    
    <item>
      <title>Database Oracle_controlandlogfiles</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_controlandlogfiles/</link>
      <pubDate>Thu, 18 Aug 2022 16:28:08 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_controlandlogfiles/</guid>
      <description>管理控制文件 控制文件是Oracle数据库最重要的物理文件之一，每个Oracle数据库至少有称控制文件。启动数据库实例时，根据初始化参数查找控制文件并读取控制文件中的内容，然后根据控制文件中的信息在实例和数据库之间建立起关联。如果无法找到控制文件或控制文件被损坏，数据库实例将无法启动，且很难修复。 控制文件简介 Oracle数据库中，控制文件是一个很小（10MB范围内）的二进制文件，含有数据库的结构信息，包括数据文件和日志文件。控制文件在数据库创建时被自动创建，在数据库发生物理变化时更新。任何时候都不要手动编辑控制文件。 Oracle系统提供了备份文件和多路复用的机制，当控制文件损坏时，用户可以通过先前的备份来恢复控制文件。 及时备份控制文件 当数据库的物理组成发生变化时，控制文件也会变更，需要及时备份控制文件。 保护控制文件 采用多种策略或准则保护控制文件，目前主要有多路复用控制文件和备份控制文件。 控制文件的多路复用 至少建立两个控制文件，并且两个控制文件最好分别保存在不同的磁盘中，避免由于某个磁盘故障而发生无法启动数据库的风险。即在系统不同的位置上同时存放多个控制文件的副本。 初始化参数CONTROL_FILES中列出了当前数据库所有的控制文件名，Oracle根据CONTROL_FILES参数中的信息同时修改所有的控制文件，但只读取其中第一个控制文件的信息。在整个数据库运行期间，如果任何一个控制文件被损坏，实例就不能再继续运行。 实现多路复用包括更改CONTROL_FILES参数和复制控制文件两个步骤： 更改CONTROL_FILES参数：在SPFILE中，使用ALTER SYSTEM更改CONTROL_FILES参数值。 停止Oracle服务，关闭数据库，并将第一个控制文件复制到新增加的目录下并重命名，启动数据库验证。 创建控制文件 如果突发意外，导致数据库的所有控制文件全部丢失或损坏，只能手工创建一个新的控制文件。 CREATE CONTROLFILE REUSE DATABASE db_name LOGFILE GROUP 1 redofiles_list1 GROUP 2 redofiles_list2 GROUP 3 redofiles_list3 ... DATAFILE datafile1 datafile2 datafile3 ... MAXLOGFILES max_value1 -- 永久性参数 MAXLOGMEMBERS max_value2 -- 永久性参数 MAXINSTANCES max_value3 -- 永久性参数 MAXDATAFILES max_value4 -- 永久性参数 NORESETLOGS|RESETLOGS ARCHIVELOG|NOARCHIVELOG; 若需要修改数据库的某个永久性参数，必须重新创建控制文件。 创建控制文件过程 查看数据文件和重做日志文件：若数据库中所有的控制文件和日志文件已经丢失，数据库已无法打开，就无法通过查询数据字典来获得数据文件和日志文件信息，只能查看告警日志文件中的内容。如果数据库可以打开，在v$logfile查看日志文件，在v$datafile查看数据文件，在v$controlfile查看控制文件。 关闭数据库：若数据库处于打开状态，在system模式使用SHUTDOWN IMMEDIATE关闭数据库。 备份文件：在操作系统备份国有的数据文件和重做日志文件，在使用CREATE CONTROLFILE创建新控制文件时，可能损坏数据文件和日志文件。 启动数据库实例：启动但不加载数据库。 创建新的控制文件：使用CREATE CONTROLFILE创建一个新的控制文件。 编辑参数：编辑SPFILE文件中的CONTROL_FILES参数，使其指向新建的控制文件。 打开数据库：alter database open。若创建控制文件使用了RESETLOGS语句，需要以恢复方式打开数据库，alter database open resetlogs。 备份和恢复控制文件 备份控制文件 控制文件有两种备份方式，备份为二进制文件或脚本文件。 备份为二进制文件：ALTER DATABASE BACKUP CONTROLFILE TO file_path;。 备份为脚本文件：ALTER DATABASE BACKUP CONTROLFILE TO TRACE;。脚本文件以文本形式备份，也称为跟踪文件，实际是一个SQL脚本，可以利用它来重新创建新的控制文件，跟踪文件存放位置由USER_DUMP_DEST参数决定。 恢复控制文件 控制文件损坏后，重新指定CONTROL_FILES参数，使它指向备份的控制文件，即可重新启动数据库。 控制文件本身损坏，目录仍可访问：关闭数据库，复制一个多路复用文件覆盖损坏文件，重新启动数据库。 磁盘介质永久性损坏：关闭数据库实例，修改初始化参数指向新的控制文件，重新启动数据库。 删除控制文件 关闭数据库，编辑初始化参数CONTROL_FILES，清除需要删除的控制文件名称，重新启动数据库。 不能将控制文件全部删除，至少保留两个，否则数据库将无法启动。 查询控制文件信息 -- 包含所有控制文件的名称和状态信息 v$controlfile -- 包含控制文件中各个记录文档段的信息 v$control_record_section -- 包含系统所有初始化参数 v$parameter 管理重做日志文件 重做日志文件通常也称为日志文件，是保证数据库安全和数据库备份和恢复的文件，管理员可以根据日志文件和数据库文件，将崩溃的数据库恢复到最近一次记录日志时的状态。 重做日志文件 重做日志文件用于记载事务操作引起的数据变化，当执行DDL或DML操作时，由LGWR进程将缓冲区中与该事务相关的重做记录全部写入重做日志文件。当丢失或损坏数据库中的数据时，Oracle会根据重做日志文件中的记录恢复丢失的数据。 日志文件的内容及数据恢复 重做日志文件由重做记录组成，重做记录又称为重做条目，由一组变更向量组成。每个变更向量都记录了数据库中某个数据块所做的修改。 利用重做记录，不禁能够恢复对数据文件所做的修改操作，还能恢复对回退段所做的修改操作。 重做记录以循环方式在SGA区的重做日志高速缓冲区中进行缓存。当一个事务被提交时，LGWR将该事务相关的所有重做记录全部写入重做日志文件中，同时生成一个系统变更码（SCN）。系统变更码会随着重做记录一起保存到重做日志文件组中，以标识与重做记录相关的事务。只有当某个事务所产生的重做记录全部被写入重做日志文件后，才会认为该事务提交成功。 正在被LGWR进程写入的重做日志文件处于当前状态；正在被实例用于数据库恢复的重做日志文件处于活动状态；其他重做日志文件处于未活动状态。可查询v$logfile获取重做日志文件的状态。 增加日志组及其成员 一个数据库至少需要两个重做日志文件组，每个组可以包含一个或多个重做日志成员。对于重做日志文件的日常维护工作，需要具有ALTER DATABASE系统权限。Oracle会自动为新建的重做日志组设置编号，一般是在当前最大组号之后递增。也可指定编号，但日志组编号必须是连续的，不能跳跃。 添加新的重做日志文件组 -- 通常大小10M-50M，默认为50M ALTER DATABASE ADD LOGFILE [GROUP num] (&amp;#39;filename1&amp;#39;,&amp;#39;filename2&amp;#39;) SIZE 20M; -- 添加一个单一的重做日志文件，并覆盖已存在的同名日志文件 -- 使用reuse时不能使用size，大小由已存在日志文件的大小决定 ALTER DATABASE ADD LOGFILE &amp;#39;filename&amp;#39; REUSE; 创建日志成员文件 -- 为重做日志组添加新成员 -- 可通过指定重做日志文件组中其他成员名称确定重做日志组 ALTER DATABASE ADD LOGFILE MEMBER &amp;#39;filename&amp;#39; TO filename | GROUP num; 删除重做日志文件 -- 删除日志成员，只在数据字典和控制文件中删除，物理文件需手动删除 ALTER DATABASE DROP LOGFILE MEMBER &amp;#39;filename&amp;#39;; -- 删除日志文件组：不再使用或大小不合适时需要删除 -- 无论日志组有多少成员，一个数据库至少需要两个日志组；只能删除处于INACTIVE的日志组；若数据库处于归档模式 -- 删除前必须确定已经被归档，可查询v$log查看重做日志文件组的状态及是否归档 ALTER DATABASE DROP LOGFILE GROUP num; -- 清空重做日志文件，重做日志组处于CURRENT状态可执行 ALTER DATABASE CLEAR LOGFILE GROUP num; -- 若要清空的重做日志文件组未归档，还需使用ALTER DATABASE CLEAR UNARCHIVED LOGFILE 更改重做日志文件的位置或名称 关闭数据库：shutdown。</description>
    </item>
    
    <item>
      <title>Database Oracle_plsqlblock</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_plsqlblock/</link>
      <pubDate>Thu, 18 Aug 2022 16:27:12 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_plsqlblock/</guid>
      <description>存储过程 存储过程是一种命名的PL/SQL块，既可以没有参数，也可以有若干个输入、输出参数，或有多个既作为输入又作为输出的参数，通常没有返回值。存储过程被保存在数据库中，不可以被SQL语句直接执行或调用，只能通过EXECUTE命令执行或在PL/SQL块内部被调用。存储过程是已经编译好的代码，调用时执行效率非常高。 -- 创建存储过程 -- parameter是存储过程被调用/执行时用到的参数，而不是存储过程内定义的内部变量，类型不能指定长度 CREATE [OR REPLACE] PROCEDURE pro_name [(parameter1 [IN|OUT] [,parameter2]...)] IS|AS BEGIN plsql_sentences; [EXCEPTION] [dowith_sentences;] -- 异常处理语句 END [pro_name]; -- 调用存储过程 EXEC | EXECUTE pro_name; 存储过程的参数 IN模式：输入类型，由调用方传入，只能被存储过程读取，默认模式。参数类型不能指定长度。位于参数名称之后。
指定名称传递参数：pro_name(parameter=&amp;gt;value1[,parameter2=&amp;gt;value2]...)，与定义顺序无关，与参数个数有关。 按位置传递：提供的参数值顺序必须与存储过程中定义的参数顺序相同。 混合方式传递：在某个位置使用指定名称传递方式传入参数后，后面也要使用指定名称传递。因为指定名称传递方式有可能已经破环了参数原始的定义顺序。 OUT模式：输出类型参数，表示此参数已在存储过程中被赋值，可以传递到存储过程之外的环境中，位于参数名称之后。
在PL/SQL块中调用OUT模式，需要在DECLARE部分定义与存储过程中OUT参数兼容的若干变量。 使用EXEC执行OUT模式的存储过程，需要在SQL*PLUS环境中使用VARIABLE声明变量，用于存储OUT参数的返回值。 IN OUT模式：调用存储过程时，从外界向该参数传入值，存储过程执行完毕后，该参数的返回值被传回给外界。
IN参数的默认值 支持在IN参数声明的同时初始化默认值，传值时若带默认值的参数不传值，建议使用指定名称传递参数。 删除存储过程 DROP PROCEDURE pro_name; 函数 存储在数据库中的命名程序块，函数一般用于计算和返回一个值，函数的调用是表达式的一部分，过程的调用是一条PL/SQL语句。函数必须有一个返回值，过程则没有。 创建函数 函数可以接受零或多个输入参数，并且必须有返回值。由于函数有返回值，在主体部分必须使用RETURN语句返回函数值，并且返回值类型与声明时的类型一致。 CREATE [OR REPLACE] FUNCTION fun_name[(parameter1[,parameter2]...)] RETURE data_type IS [inner_variable] BEGIN plsql_sentence; [EXCEPTION] [dowith_sentences;] END [fun_name]; 调用函数 由于函数有返回值，调用函数时，必须使用一个变量保存函数的返回值。 DECLARE variable_name data_type; BEGIN variable_name:=fun_name(value); END; 删除函数 DROP FUNCTION fun_name; 触发器 触发器可以看作一种特殊的存储过程，定义了一些在数据库相关事件发生时应执行的功能代码块，通常用于管理复杂的完整性约束，或监控对表的修改，或通知其他程序，也可实现对数据的审计功能。 能够引起触发器运行的操作被称为触发事件，如执行DML语句，执行DDL语句，引发数据库系统事件，引发用户事件。 创建触发器 触发器根据触发事件和触发器执行情况，分为5类。 行级触发器：DML语句对每一行数据进行操作时都会触发。在行级触发器中，可以访问当前正在受影响的数据行，可以通过行标识符来实现，列标识符分为原值标识符(:old.</description>
    </item>
    
    <item>
      <title>Database Oracle_plsql</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_plsql/</link>
      <pubDate>Thu, 18 Aug 2022 16:26:25 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_plsql/</guid>
      <description>PL/SQL简介 PL/SQL是一种过程化语言，可以控制程序的执行流程、定义变量，实现比较复杂的业务逻辑，是Oracle的专用语言，是对标准SQL语言的扩展，可在内部使用SQL语句。 PL/SQL块结构 PL/SQL程序以块为基本单位，整个PL/SQL块分布3部分：声明、执行、异常处理。 每一条语句都必须以分号结束，每条SQL语句可以写成多行的形式，也必须以分号结束。一行中可以有多条SQL语句，之间必须用分号分隔。 [DECLARE] -- 声明部分，可选。声明块中用到的变量、常量、游标等，只能在当前块中使用 BEGIN -- 执行部分，必需。整个块的主体，包括主要的逻辑控制和运算 [EXCEPTION] -- 异常处理，可选。处理执行部分出现的异常，执行完毕整个块直接结束 END 代码注释和标识符 注释 -- 单行注释 /* 多行注释 */ 标识符 定义变量、常量时，每行只能定义一个变量或常量，以分号结尾。 定义变量、常量时，名称必须以英文字符开头，最大长度为30个字符。若以其他字符开始，用双引号引住。 定义变量、常量时，名称只能使用字母、数字、_、$、#。若使用其他字符，用双引号引住。 定义变量、常量时，不能使用Oracle关键字，若使用，必须用双引号引住。 除了由引号引起来的字符串以外，PL/SQL不区分字母的大小写。标准PL/SQL字符集时ASCII字符集的一部分。 分界符 分界符是对PL/SQL有特殊意义的符号，用来将标识符相互分隔开。 文本 数字文本：整数或浮点数，可使用科学计数法和幂操作符**。 字符文本：用单引号引住的单个字符，可以是PL/SQL支持的所有可打印字符。 布尔文本：TRUE、FALSE、NULL。主要用于条件表达式。 日期时间文本：日期时间值。日期文本必须用单引号引住且与日期格式和日期语言匹配。 字符串文本：两个或两个以上字符组成的多个字符值，必须用单引号引住。 10g之前，若字符串文本包含单引号，必须用两个单引号表示。10g之后，可以使用其他分隔符赋值。 -- 10g之前 string_var:=&amp;#39;I&amp;#39;&amp;#39;m a string.&amp;#39;; -- 10g之后 string_var:=q&amp;#39;[I&amp;#39;m a string.]&amp;#39; 数据类型、变量和常量 数据类型是描述数据存储的内存结构，它决定变量中所存储的数据的类型。变量是一种用名称进行识别的标识符号，可以存储不同类型的值。 基本数据类型 数值类型 NUMBER：存储整数或浮点数。可使用NUMBER(p,s)格式化数字，p表示精度（所有有效数字的个数），s表示刻度范围（小数点右边小数位的个数）。 BINARY_INTEGER：存储整数。 PLS_INTEGER：存储整数。 NUMBER的子类型(等价的类型别名)：DEC|DECIMAL|DOUBLE|INTEGER|INT|NUMERIC|SMALLINT。 字符类型 VARCHAR2(maxlength)：存储长度可变的字符串，maxlength定义时必须给出，没有默认值。 maxlength最大为32767，数据库类型VARCHAR2最大长度为4000，所以大于4000的PL/SQL变量不可以赋值给数据库的变量，只能赋值给LONG类型的数据库变量。 CHAR(maxlength)：指定长度的字符串，默认长度为1，最大32767。如果赋给CHAR的值小于maxlength，后面用空格补全。数据库类型中的CHAR只有2000字节。 LONG：可变字符串，最大长度32767字节，数据库类型的LONG最大可达2GB。 NCHAR|NVARCHAR2：PL/SQL8.0以后加入的类型，长度根据各国字符集确定。 日期类型 DATE：存储日期和时间信息，存储空间7个字节，分别存储世纪、年、月、天、小时、分钟、秒。 布尔类型 BOOLEAN：流程控制和业务逻辑判断，值为TRUE、FALSE、NULL。 特殊数据类型 %TYPE类型 使用%TYPE可以声明一个与指定列相同的数据类型，通常跟在指定列名的后面。 declare var_ename scott.</description>
    </item>
    
    <item>
      <title>Database Oracle_sqlbasical</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_sqlbasical/</link>
      <pubDate>Thu, 18 Aug 2022 16:26:14 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_sqlbasical/</guid>
      <description>SQL语言简介 SQL，结构化查询语言，是一种在关系型数据库中定义和操纵数据的标准语言。 SQL语言的特点 SQL是一种非过程化语言，让用户不用考虑诸如数据的存储格式和存储路径等复杂问题就能按照自己的要求在高层数据结构上操作。 综合统一、集合性、统一性、高度非过程化、语言简单，易学易用、以同一种语法结构提供两种使用方式、是所有关系数据库的公共语言。 SQL语言的分类 数据查询语言（DQL） 检索数据库中的数据，主要是SELECT。 数据操纵语言（DML） 改变数据库中的数据，主要包括INSERT、UPDATE、DELETE。CALL、LOCKTABLE、MERGE。 事务控制语言（TCL） 维护数据的统一性，包括COMMIT、ROLLBACK、SAVEPOINT。 数据定义语言（DDL） 建立、修改和删除数据库对象，包括CREATE、ALTER、DROP。TRUNCATE。 数据控制语言（DCL） 执行权限授予和权限收回操作，包括GRANT、REVOKE。 SQL语言的编写规则 SQL关键字不区分大小写，字符值区分大小写。 用户模式 为便于管理用户创建的数据库对象，引入模式概念，某个用户创建的数据库对象属于该用户模式。 模式与模式对象 模式是一个数据库对象的集合，模式名称与数据库用户名称相同。在一个模式内部不可以直接访问其他模式的数据库对象，即使具有访问权限，也需要指定模式名称才可以访问。 模式对象是用户创建的逻辑结构，用以存储或引用数据，包括段以及用户拥有的其他非段的数据库对象。模式拥有模式对象。 一个不为某个用户所拥有的数据库对象不能被称为模式对象，如角色、表空间、目录等数据库对象。 查询用户模式表 在用户模式下，查询user_tables。 在system模式下，查询dba_tables。 检索数据 -- 检索基本语法格式 SELECT {[ DISTINCT | ALL] columns | *} [INTO table_name] FROM {tables | views | other SELECT }[WHERE conditions] [GROUP BY columns] [HAVING conditions] [ORDER BY columns] 简单查询 只包含SELECT子句和FROM子句的查询。 在Oracle数据库中，ROWID是行标识符，是内部使用的隐藏列，长度为18字符，包含该行数据的物理地址。使用DESCRIBE无法显示，但可在SELECT语句中检索。 查询日期列 -- 以简体中文显示日期结果 alter session set nls_date_language = &amp;#39;SIMPLIFIED CHINESE&amp;#39;; -- 以美国英语显示日期结果 alter session set nls_date_language = &amp;#39;AMERICAN&amp;#39;; -- 以特定格式显示日期结果 alter session set nls_date_format = &amp;#39;YYYY&amp;#34;年&amp;#34;MM&amp;#34;月&amp;#34;DD&amp;#34;日&amp;#34;&amp;#39;; 处理NULL值 NULL表示未知值，既不是空，也不是0，插入数据时不提供值且未设置默认值，则结果为NULL。实际应用中，NULL显示结果往往不符合要求，需使用NUL函数，转换为合理的结果。</description>
    </item>
    
    <item>
      <title>Database Oracle_sqlplus</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_sqlplus/</link>
      <pubDate>Thu, 18 Aug 2022 16:25:52 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_sqlplus/</guid>
      <description>SQL*PLUS与数据库的交互 SQL*PLUS是一个基于C/S两层结构的客户端操作工具，客户层和服务器层可在不同主机上。 设置SQL*PLUS的运行环境 运行环境是用来输入、执行SQL*PLUS命令和显示返回结果的场所。 SET命令 用户可以使用SET命令设置运行环境。通过SET设置的环境变量是临时的，退出环境后全部丢失。 -- system_variable:变量名 value:变量值 SET system_variable value -- 常用变量设置 -- PAGESIZE:设置从顶部标题至页结束之间的行数，包括分割线和空行，默认value=14 SET PAGESIZE value -- NEWPAGE:设置一页中空行的数量，默认value=1 SET NEWPAGE value -- LINESIZE:设置一行中所显示的最多字符总数，默认value=80 SET LINESIZE value -- PAUSE:设置输出结果是否滚动，value=OFF|ON|text，默认OFF，设置ON再设置text，每次暂停显示text SET PAUSE value -- NUMFORMAT:设置数值的默认显示格式，掩码：9，0，$，S，. SET NUMFORMAT format 常用SQL*PLUS命令 SQL*PLUS命令执行完成后，不保存在SQL缓冲区。 -- 提供被查询命令的标题、功能描述、缩写形式和参数选项，?表示命令的部分字符 HELP|? [topic] -- 查询指定数据对象的组成结构，包括表、视图、过程、函数和程序包等 DESC[RIBE] object_name; -- 将查询结果输出到指定文件，默认CREATE，OFF|OUT表示关闭SPOOL，关闭输出之后，才能在文件中看到内容 SPO[OL] [file_name[.ext] [CRE[ATE] | REP[LACE] | APP[END]] | [OFF | OUT] -- 定义一个用户变量并分配一个CHAR值 DEF[INE] [variable] | [variable = text] -- 显示SQL*PLUS系统变量或环境变量的值 -- option常用选项有ALL/PARAMETERS [parameter_name]/SGA/SPOOL/USER等 SHO[W] option -- 在记事本中编辑SQL缓冲区中的最近一条SQL语句或PL/SQL块，不加参数表示直接编辑最近一条 -- 执行最近一条SQL语句，可以运行`/`来执行 EDIT [file_name[.</description>
    </item>
    
    <item>
      <title>Database Oracle_structure</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_structure/</link>
      <pubDate>Thu, 18 Aug 2022 16:25:40 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_structure/</guid>
      <description>Oracle 11g体系结构概述 Oracle数据库是一格逻辑概念，而不是物理概念上安装了Oracle数据库管理系统的服务器。Oracle数据库管理系统有3个重要概念：实例、数据库和数据库服务器。 实例是指一组Oracle后台进程以及在服务器中分配的共享内存区域；数据库是由基于磁盘的数据文件、控制文件、日志文件、参数文件和归档日志文件等组成的物理文件集合；数据库服务器是指管理数据库的各种软件工具（如SQL-Plus、OEM等）和实例及数据库3个部分。从实例与数据库之间的辩证关系来讲，实例用于管理和控制数据库；而数据库为实例提供数据。一个数据库可以被多个实例装载和打开；而一个实例在其生存期内只能装载和打开一个数据库。 数据库的主要功能就是存储数据，数据库存储数据的方式通常称为存储结构，Oracle数据库的存储结构分为逻辑存储结构和物理存储结构。逻辑存储结构用于描述Oracle内部组织和管理数据的方式，物理存储结构用于展示Oracle在操作系统中的物理文件组成情况。 SQL命令从客户端发出后，由Oracle的服务器进程进行响应，然后在内存区域中进行语法分析、编译和执行，接着将修改后的数据写入数据文件，将数据库的修改信息写入日志文件，最后将SQL的执行结果返回给客户端。 逻辑存储结构 Oracle的逻辑存储结构是一种层次结构，主要由表空间、段、数据区和数据块等概念组成。逻辑结构是面向用户的，当用户使用Oracle设计数据库时，其使用的就是逻辑存储结构。 数据块 数据块（Data Block）是Oracle逻辑存储结构中的最小的逻辑单位，也是执行数据库输入／输出操作的最小存储单位。Oracle数据存放在“Oracle数据块”中，而不是“操作系统块”中。通常Oracle数据块是操作系统块的整数倍。Oracle数据块有一定的标准大小，其大小被写入到初始化参数DB_BLOCK_SIZE中。Oracle支持在同一个数据库中使用多种大小的块，与标准块大小不同的块就是非标准块。 数据块中可以存放表数据、索引数据和簇数据等，无论存放哪种类型的数据，其结构都是相同的。数据块由块头、表目录、行目录、空余空间和行数据这5部分组成 块头：存放数据块的基本信息，如块的物理地址、块所属的段的类型。 表目录：存放表的相关信息。如果数据块中存储的数据是表数据，则表目录中存储有关这些表的相关信息。 行目录：如果块中有行数据存在，则这些行的信息将被记录在行目录中。这些信息包括行的地址等。 空余空间：空余空间是一个块中未使用的区域，这片区域用于新行的插入和已经存在的行的更新。 行数据：用于存放表数据和索引数据的地方，这部分空间已被数据行所占用（如表中的若干行数据记录）。 数据区 数据区（Extent也可称作数据扩展区）是由一组连续的Oracle数据块所构成的Oracle存储结构，一个或多个数据块组成一个数据区，一个或多个数据区再组成一个段（Segment）。使用数据区的目的是用来保存特定数据类型的数据，数据区是Oracle存储分配的最小单位，Oracle就以数据区为单位进行存储空间的扩展。当一个段中的所有空间被使用完后，Oracle系统将自动为该段分配一个新的数据区。一个Oracle对象至少包含一个数据区。设置一个表或索引的存储参数包含设置它的数据区大小。 段 段（Segment）是由一个或多个数据区构成，它不是存储空间的分配单位，而是一个独立的逻辑存储结构，是为特定的数据对象（如表、索引、回滚等）分配的一系列数据区。段内包含的数据区可以不连续，并且可以跨越多个文件，使用段的目的是用来保存特定对象，Oracle也把这种占用空间的数据对象统一称为段。一个段只属于一个特定的数据对象，每当创建一个具有独立段的数据对象时，Oracle将为它创建一个段。 数据段：数据段中保存的是表中的数据记录。当创建一个表时，系统自动创建一个以该表的名字命名的数据段。 索引段：索引段中包含了用于提高系统性能的索引。一旦建立索引，系统自动创建一个以该索引的名字命名的索引段。 回滚段：回滚段（也可称作撤销段）中保存了回滚条目，Oracle将修改前的旧值保存在回滚条目中。利用这些信息，可以撤销未提交的操作，以便为数据库提供读入一致性和回滚未提交的事务，即用来回滚事务的数据空间。当一个事务开始处理时，系统为之分配回滚段，回滚段可以动态创建和撤销。Oracle 11g系统有个默认的回滚段，其管理方式既可以是自动的，也可以是手工的。 临时段：当执行创建索引、查询等操作时，Oracle可能会使用一些临时存储空间，用于暂时性地保存解析过的查询语句以及在排序过程中产生的临时数据。Oracle系统将在专门用于存储临时数据的表空间中为操作分配临时段。 在执行CREATE INDEX、SELECT ORDER BY、SELECT DISTINCT和SELECT GROUP BY等几种类型的SQL语句时，Oracle系统就会在临时表空间中为这些语句的操作分配一个临时段。在数据库管理过程中，若经常需要执行上面这类SQL语句，最好调整SORT_AREA_SIZE初始化参数来增大排序区，从而使排序操作尽量能够在内存中完成，以获得更好的执行效率，但同时这对数据库服务器的内存空间提出了更大的要求。 表空间 表空间是数据库的最大逻辑划分区域，通常用来存放数据表、索引、回滚段等数据对象（即Segment），任何数据对象在创建时都必须被指定存储在某个表空间中。表空间（属逻辑存储结构）与数据文件（属物理存储结构）相对应，一个表空间由一个或多个数据文件组成，一个数据文件只属于一个表空间；Oracle数据的存储空间在逻辑上表现为表空间，而在物理上表现为数据文件。 每个数据库至少有一个表空间（即SYSTEM表空间），表空间的大小等于所有从属于它的数据文件大小的总和。由于表空间在物理上（即磁盘上）包含操作系统中的一个或多个数据文件，因此在表空间中创建的数据对象就存在以下两种情况。 若表空间只包含一个数据文件，则该表空间中的所有对象都存储在这个数据文件中。 若表空间包含多个数据文件，则Oracle即可将数据对象存储在该表空间的任意一个数据文件中，也可以将同一个数据对象中的数据分布在表空间的多个数据文件中。 在创建数据库时，Oracle系统会自动创建多个默认的表空间，这些表空间除了用于管理用户数据的表空间之外，还包括用于管理Oracle系统内部数据（如数据字典）的表空间，下面列举了Oracle 11g版本默认创建的主要表空间。 SYSTEM表空间——系统表空间。它用于存放Oracle系统内部表和数据字典的数据，如表名、列名、用户名等。Oracle本身不赞成将用户创建的表、索引等存放在系统表空间中。表空间中的数据文件个数不是固定不变的，可以根据需要向表空间中追加新的数据文件。 SYSAUX表空间。它是Oracle 11g新增加的表空间，是随着数据库的创建而创建的，它充当SYSTEM的辅助表空间，降低了SYSTEM表空间的负荷，主要存储除数据字典以外的其他数据对象。SYSAUX表空间一般不存储用户的数据，由Oracle系统内部自动维护。 UODO表空间——撤销表空间。它用于存储撤销信息的表空间。当用户对数据表进行修改操作（包括插入、更新、删除等操作）时，Oracle系统自动使用撤销表空间来临时存放修改前的旧数据。当所做的修改操作完成并执行提交命令后，Oracle根据系统设置的保留时间长度来决定何时释放掉撤销表空间的部分空间。一般在创建Oracle实例后，Oracle系统自动创建一个名字为UNDOTBS1的撤销表空间，该撤销表空间对应的数据文件是UNDOTBS01.DBF。 USERS表空间——用户表空间。它是Oracle建议用户使用的表空间，可以在这个表空间上创建各种数据对象。例如，创建表、索引、用户等数据对象。Oracle系统的样例用户scott对象就存放在USERS表空间中。 除了Oracle系统默认创建的表空间外，用户可根据应用系统的实际情况及其所要存放的对象类型创建多个自定义的表空间，以区分用户数据与系统数据。此外，不同应用系统的数据应存放在不同的表空间上，而不同表空间的文件应存放在不同的盘上，从而减少I/O冲突，提高应用系统的操作性能。 物理存储结构 Oracle数据库的物理存储结构由多种物理文件组成，主要有数据文件、控制文件、重做日志文件、归档日志文件、参数文件、密码文件和警告日志文件等。 数据文件 用于保存用户应用程序数据和Oracle系统内部数据的文件，创建表空间的同时会创建数据文件。一个数据文件只能属于一个表空间。 在表空间创建对象时，存储的数据文件由Oracle系统选择，一个数据对象的数据可以全部存储在一格数据文件中，也可以分布存储在同一个表空间的多个数据文件中。 读取数据时，先从数据文件读入高速数据缓冲区。若读取的数据不在缓冲区，需要读入并存储在缓冲区。修改和插入数据时，不会立即写入数据文件，而是保存在缓冲区内，由后台进程DBWR决定如何写入数据文件，减少了磁盘I/O操作。 数据文件有3种类型： 系统数据文件：属于系统表空间，存放特殊的用户数据和Oracle系统本身的数据。 撤销数据文件：属于撤销表空间，修改数据使用撤销段(位于撤销表空间)临时存放修改前的旧数据。 用户数据文件：用于存放用户应用系统数据，包括与应用系统有关的所有信息。 Oracle 9i之后，Oracle将临时表空间对应的临时数据文件与一般数据文件分开。 控制文件 控制文件是一个二进制文件，记录数据库的物理结构，主要包括数据库名、数据文件和日志文件的名字和位置、数据库建立日期等信息。系统运行过程中，还存放有系统更改好、检查点信息及归档的当前状态等信息。控制文件一般在Oracle系统安装或创建数据库时自动创建，出于安全考虑，系统会自动创建2个或3个控制文件，记录相同的信息。 Oracle实例启动必须访问控制文件，若控制文件记录了错误信息或找不到可用控制文件，实例无法正常启动。 Oracle实例正常启动时，首先访问初始化参数文件SPFILE，然后Oracle为SGA分配内存。这时Oracle实例处于安装状态，并且控制文件处于打开状态，接下来自动读出控制文件中所有数据文件和日志文件信息，并打开当前数据库中所有的数据文件和日志文件供用户访问。 每个数据库至少有一个控制文件，一个数据库可同时拥有多个控制文件，一个控制文件只能属于一个数据库。数据库物理组成更改时，Oracle自动更新控制文件，数据恢复时，也需要控制文件。 日志文件 记录对数据库所做的修改，对数据库所做的修改几乎都记录在日志文件中。出现问题时，可以通过日志文件得到原始数据。每个Oracle实例都启动一个日志线程记录数据库变化，日志线程由若干日志组构成，每个日志组有一个或多个日志文件。 运行过程中产生的日志信息，首先临时存放在SGA的重做日志缓冲区中，发出COMMIT命令或日志缓冲区信息满1/3时，LGWR将日志信息从缓冲区读取出来，写入日志文件组编号较小的文件里，一个日志组写满后接着写另一个日志组。所有日志文件使用一遍后，再次转向第一个日志组重新覆写。 重做日志文件：记录数据库所有发生过的更改信息及由Oracle内部行为而引起的数据库变化信息，数据库恢复时，可以日志文件读取原始记录。数据库运行期间，执行COMMIT时，数据库首先将原始记录写入日志文件，成功后才将新的记录传递给应用程序。 归档日志文件：日志覆写会导致较早日志信息被覆盖，开启归档模式，会在各个日志文件都被写满而即将覆盖之前，由ARCH将即将被覆盖的日志文件中的日志信息读取写入归档日志文件。LGWR需要等待ARCH结束才能开始覆写文件，延迟系统响应，同时占用大量磁盘空间，默认不启用归档模式。 服务器参数文件 SPFILE是二进制文件，记录Oracle数据库的基本参数信息。在安装数据库系统时由系统自动创建，参数由Oracle系统自动维护，若有修改参数，尽可能避免对文件直接编辑，使用OEM或ALTER SYSTEM。 密码文件 验证sysdba权限的二进制文件，远程用户以sysdba或sysoper连接到数据库时，一般要用密码文件验证。 警告文件 记录Oracle系统的运行信息（实例的启动与关闭、建立表空间、增加数据文件等）和错误信息（空间扩展失败、启动实例失败等）。警告文件会越来越大，应该定期删除。 跟踪文件 后台进程跟踪文件：记录后台进程的警告或错误信息。 用户进程跟踪文件：记录与用户进程相关信息，主要用于跟做SQL语句。 Oracle 11g服务器结构 Oracle服务器主要由实例、数据库、程序全局区和前台进程组成。实例提供管理数据库的功能，数据库用来存储系统数据。实例可划分为SGA和后台进程两部分，SGA使用操作系统的内存资源，后台进程需要使用CPU与内存资源。PGA是一个非共享的内存区域，用于管理用户进程的私有资源。前台进程可以划分为用户进程和服务器进程，需要使用CPU和内存资源。 系统全局区（SGA） SGA是所有用户进程共享的一块内存区域。主要由高速数据缓冲区、重做日志缓冲区、共享池、大型池和Java池等内存结构组成。SGA随数据库实例启动加载到内存中，实例关闭时，SGA区域也消失。 高速数据缓冲区：存放最近访问过的数据块，若访问数据不在缓冲区，先从数据文件读入缓冲区再从缓冲区将数据返回。经常或最近访问的数据块被放置到缓冲区前端，不常访问的放置到后端，缓冲区被填满是，自动挤掉不常访问的数据块。缓冲区分为3个部分。 脏数据区：存放已被修改过的数据，这些数据等待被写入数据文件。 空闲区：不包含任何数据，可以被写入数据。 保留区：包含正在被用户访问的数据块和明确保留以作为将来使用的数据块，被保留在缓冲区。 重做日志缓冲区：存放对数据块进行修改操作时产生的日志信息，写入重做日志文件前，先存放在缓冲区，在检查点发生或缓冲区数据达到一定值时，写入重做日志文件。重做日志缓冲区的大小对数据库性能的影响较小，通常较大的重做日志缓冲区能减少I/O读写次数。 共享池：SGA保留的内存区域，用于缓存SQL语句、PL/SQL语句、数据字典、资源锁、字符集和其他控制结构。包括库高速缓冲区和字典高速缓冲区。 库高速缓冲区：主要包括共享SQL区和私有SQL区。存放最近用过的SQL语句、PL/SQL语句的文本和执行计划，下次执行相同语句时，直接使用执行计划。每条被缓存的语句分为两个部分，分别存储在共享SQL区和私有SQL区。共享SQL区存放语法分析结果和执行计划，私有SQL区存放语句中的绑定变量、环境和会话等信息。 字典高速缓冲区：存放Oracle系统内部管理所需要的数据字典信息，如用户名、数据对象和权限等。 大型池：不是必需内存结构，在特殊情况下，实例使用大型池减轻共享池访问压力。 使用恢复管理器进行备份和恢复操作时，大型池作为I/O缓冲区使用。 使用I/O Slave仿真异步I/O功能时，大型池作为I/O缓冲区使用。 执行具有大量排序操作的SQL语句。 使用并行查询时，大型池作为并行查询进程交换信息的地方。 &amp;ndash;若未设置大型池，实例需要使用时，会在共享池或PGA分配缓存空间，影响共享池和PGA的工作效率。&amp;ndash; Java池：提供内存空间给Java虚拟机使用，支持在数据库中运行Java程序包。 流池：在数据库与数据库之间进行信息共享。 程序全局区（PGA） 也称用户进程全局区，内存区在进程私有区而不是共享区。每个Oracle服务器进程只能访问属于自己的那部分PGA资源，各个服务进程的PGA总和即为实例的PGA大小。PGA通常包括私有SQL区和会话区。 私有SQL区：存储变量以及SQL语句运行时的内存结构信息。把私有SQL区与对应的共享SQL区就可获得一条SQL语句的完整缓存数据。私有SQL区可分为静态区和动态区。静态区的信息在会话过程中保持不变，会话关闭时才释放。动态区信息在整个会话过程中不断变化，SQL语句执行完毕释放。 会话区：存放用户的会话信息。如果数据库处于共享服务器连接模式下，会话区位于SGA而不是PGA。 前台进程 前台进程包括用户进程和服务器进程，不属于实例的一部分。 用户进程：能够产生或执行SQL语句的应用程序。 连接：用户进程与实例直接建立的通信渠道。 会话：用户进程与实例建立连接后形成的用户与实例之间的交互方式，一般是用户发出请求，数据库实例为用户返回响应消息的方式。 服务器进程：处理用户会话过程中想数据库实例发出的SQL语句或SQL-PLUS命令，分为专用服务器模式和共享服务器模式。专用模式下，每个用户进程都有一个专用的服务器进程，服务器进程代表用户执行SQL验收，必要时可回传执行结果给用户进程。共享模式下，每个用户不直接与服务器进程连接，而是连接到分派程序，每个分派程序可以同时连接多个用户进程。 后台进程 后台进程是一组运行在Oracle服务器端的后台程序，是Oracle实例的重要组成部分。其中SMON、PMON、DBWR、LGWR、CKPT这5个后台进程必须正常启动，否则将导致数据库实例崩溃。 数据写入进程（DBWR） 主要任务是负责将内存中的脏数据回写到数据文件中。 高速数据缓冲区没有足够空闲数据块存放新数据。 检查点进程启动后，会强制要求DBWR将某些脏数据块写入数据文件。 脏数据块在高速缓冲区中存放超过3秒钟。 &amp;ndash;DBWR进程的数量不应超过系统处理器的数量，多余的无法发挥作用，还会耗费系统资源。&amp;ndash; 检查点进程（CKPT） 检查点进程可以看作一个事件，当发生日志切换（日志写入操作正要从一个日志组切换到另一组时），就会启动检查点进程。 日志写入进程（LGWR） 将重做日志缓冲区的数据写入重做日志文件。&amp;ndash;发生提交命令，缓冲区满1/3，日志信息存放超过3秒钟。&amp;ndash; 归档进程（ARCH） 可选进程，数据库处于归档模式时，该进程才起作用。系统比较繁忙导致LGWR等待ARCH时，可修改参数启动多个归档进程。 系统监控进程（SMON） 在数据库系统启动时执行恢复工作的强制性进程。 进程监控进程（PMON） 监控其他进程的状态，当有进程启动失败时，PMON会清除失败的用户进程，释放资源。 锁进程（LCKN） 可选进程，并行服务器模式下可出现多个锁定进程以利于数据库通信。 恢复进程（RECO） 可选进程，在分布式数据库模式下用于恢复数据不一致。 调度进程（DNNN） 可选进程，在共享服务器模式下使用，可启动多个调度进程。 快照进程（SNPN） 用于处理数据库快照的自动刷新，并通过DBMS_JOB包运行预定的数据库存储过程。 数据字典 Oracle存放关于数据库内部信息的地方，用来描述数据库的内部运行和管理情况。Oracle数据字典名称由前缀和后缀组成，使用_连接。 dba_：包含数据库实例的所有对象。 v$：当前实例的动态视图，包含系统管理和系统优化等所使用的视图。 user_：记录用户的对象信息。 gv_：分布式环境下所有实例的动态视图，包含系统管理和系统优化等所使用的视图。 all_：记录用户的对象信息及被授权访问的对象信息。 常用数据字典 -- 基本数据字典 dba_tablespaces dba_ts_quotas dab_free_cpace dba_segments dba_extents dba_tables dba_tab_columns dba_views dba_synonyms dba_sequences dba_constraints dba_indexs dba_ind_columns dba_triggers dab_source -- 所有用户的存储过程信息 dba_data_files dba_tab_grants/privs dba_objects dba_users -- 常用动态性能视图 v$database v$datafile v$log v$logfile v$archived_log v$archived_dest v$controlfile v$instance v$system_parameter v$sga v$sgastat v$parameter v$lock v$session v$sql v$sqltext v$bgprocess v$process </description>
    </item>
    
    <item>
      <title>Database Oracle_basical</title>
      <link>https://supersonnya.github.io/operation/database/oracle/database-oracle_basical/</link>
      <pubDate>Wed, 18 Aug 2021 16:20:08 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/oracle/database-oracle_basical/</guid>
      <description>Oracle发展 第6版：引入了行级锁特性，不完善的PL/SQL语言，引入联机热备份功能。 第7版：分布式事务处理功能，增强的管理功能，用于应用程序开发的新工具以及安全方法。 第8版：支持面向对象的开发及新的多媒体应用，开始具有同时处理大量用户和海量数据的特性。为支持Internet、网络计算等奠定了基础。 Oracle 8i：i代表Internet，添加了大量为支持Internet而设计的特性，为数据库用户提供了全方位的Java支持，成为第一个完全整合了本地Java运行时环境的数据库，用Java就可以编写Oracle的存储过程。 Oracle 9i：加入许多新特性，最重要的是Real Application Clusters(RAC)——集群技术。 Oracle 10g：g代表grid，最大的特性是加入了网格计算的功能。 Oracle 11g：最常用的版本，实现了信息生命周期管理等多项创新，大幅地提高了系统性能的安全性，全新的Data to Guard最大化了可用性，利用全新的高级数据压缩技术降低了数据存储的支出，明显缩短了应用程序测试环境部署及分析测试结果所花费的时间，增加了RFIDTag、DICOM医学图像、3D空间等重要数据类型的支持，加强了Binary XML的支持和性能优化。 Oracle 12c：c代表cloud，增加云计算功能，当前最新版本。 关系数据库基本理论 数据库管理技术发展阶段：人工管理、文件系统、数据库系统。 数据库系统的数据模型主要有层次模型、网状模型、关系模型和面向对象模型。目前理论成熟、使用普及的是关系模型。 关系型数据库设计范式 关系型数据库由相互联系的一组关系所组成，每个关系包括关系模式和关系值的两个方面。关系模式是对关系的抽象定义，给出关系的具体结构；关系的值是关系的具体内容，反映关系在某一时刻的状态。每个关系都需要进行规范化，使之达到一定的规范化程度，从而提高数据的结构化、共享性、一致性和可操作性。 规范化是把数据库组织成在保持存储数据完整性的同时最小化冗余数据的结构的过程。规范化的数据库必须符合关系模型的范式。范式可以防止在使用数据库时出现不一致的数据，并防止数据丢失。关系模型范式有第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、第四范式、第五范式、第六范式和BCNF范式等多种。通常数据库满足前3个范式就足够用了。 第一范式 第一范式是对关系模式的基本要求，不满足第一范式的数据库就不是关系型数据库。 第一范式是第二和第三范式的基础，是最基本的范式。包括以下指导原则： 数据组的每个属性只可以包含一个值。 关系中的每个数组必须包含相同数量的值。 关系中的每个数组一定不能相同。 如果数据表中的每一个列都是不可再分割的基本数据项，就称此数据表符合第一范式。第一范式具有不可再分解的原子特性。 第二范式 满足第二范式必须先满足第一范式。第二范式要求数据库表中的每个实体（即各个记录行）必须可以被唯一地区分。 第二范式要求实体的属性完全依赖于主关键字，不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一格新的实体，新实体与原实体之间是一对多的关系。 （员工编码，岗位）→（决定）（姓名，年龄，学历，基本工资，绩效工资，奖金）。 第三范式 满足第三范式必须先满足第二范式。第三范式要求关系表不存在非关键字列对任意候选关键字列的传递函数依赖，即第三范式要求一个关系表中不包含已在其他表中包含的非主关键字信息。 传递函数依赖：如果存在关键字段A决定非关键字段B，而非关键字段B决定非关键字段C，则称非关键字段C传递函数依赖于关键字段A。 （员工编码）→（决定）（姓名，年龄，部门编码，部门经理）。 基础 数据库的设计主要是数据库模式的设计 属性之间的关联成为数据依赖：函数依赖、多值依赖、连接依赖 规范化规则并不能帮助建立好的数据模型，只是提供了一直检验建立的数据模型是否正确的测试手段 第一范式-1NF 实体（表）的所有属性都不可分，即不包含多值属性，则满足1NF 两种方法实现非1NF的结构：数组引用和嵌套表 第二范式-2NF 函数依赖不是根据一个值导出另一个值，而是对于一个值来说，另一个值是逻辑上唯一的 不存在依赖于部分主码的属性 students_grade(student_id, course_id, grade, age) 第三范式-3NF 不能存在传递函数依赖关系 存在一个属性，它所函数依赖的属性既不是主码也不是候选码 BC范式-BCNF 消除主属性对码的部分和传递依赖 Oracle 11g新功能 增强信息生命周期管理和存储管理能力 Oracle 11g具有极新的数据划分和压缩功能，可实现更经济的信息生命周期管理和存储管理。实现了很多手工数据划分工作的自动化，扩展了已有的范围、散列和列表划分功能，增加了间隔、索引和虚拟卷划分功能。 全面回忆数据变化 Oracle 11g具有Oracle全面回忆（Oracle Total Recall）组件，可帮助管理员查询在过去某些时刻指定表格中的数据， 最大限度提高信息可用性 Oracle闪回交易（Oracle Flashback Transaction），可以轻松撤销错误交易以及任何相关交易；并行备份和恢复功能，可改善非常大数据库的备份和存储性能；“热修补”功能，不必关闭数据可就可以进行数据库修补，提高系统可用性。 Oracle快速文件 存储大型对象，包括图像、大型文本对象或一些先进的数据类型，如XML、医疗成像数据和三维对象。Oracle快速文件（Oracle Fast Files）组件使得数据库的性能完全比得上文件系统的性能。 更快的XML Oracle 11g增加了对二进制XML数据的支持，客户可以选择适合自己特定应用及性能需求的XML存储选项。 透明的加密 将透明数据加密功能扩展到卷级加密之外，具有表空间加密功能，可用来加密整个表、索引和所存储的其他数据。 嵌入式OLAP行列 OLAP行列在数据库中可以像物化图一样使用，受益于OLAP高性能的同时，开发人员可以用标准SQL实现数据查询。 连接汇合和查询结果高速缓存 增加了查询结果高速缓存等新功能。通过高速缓存和重用经常调用的数据库查询以及数据库和应用层的功能，改善应用的性能和可扩展性。 增强应用开发能力 Oracle 11g提供多种开发工具，提供的简化应用开发流程可以充分利用Oracle 11g的关键功能，这些关键功能包括客户端高速缓存、提供应用速度的二进制XML、XML处理以及文件存储和检索。 Oracle 11g管理工具 SQL*PLUS 连接语法格式：SQLPLUS username[/password][@connect_identifier] [AS SYSOPER|SYSDBA]。 关键字不区分大小写，但参数区分大小写。 Oracle企业管理器(Oracle Enterprise Manager) URL：https://localhost:1158/em。 数据库配置助手(Database Configuration Assistant, DBCA) 创建和配置数据库。 启动和关闭数据库实例 启动数据库实例 Oracle数据库实例启动过程：启动实例、加载数据库、打开数据库。 启动数据库命令格式：STARTUP [NOMOUNT | MOUNT | OPEN | FORCE] [RESCRICT] [PFILE=filename] NOMOUNT：启动实例，不加载数据库。 通常在创建新数据库或重建控制文件时使用。 MOUNT：启动实例，加载数据库，不打开数据库。 通常在进行数据库维护时使用，比如执行数据库完全恢复操作、更改数据库的归档模式等。 OPEN：启动实例，加载数据库，打开数据库，默认选项。 FORCE：终止实例并重新启动数据库，具有一定的强制性。 RESTRICT：指定以受限制的会话方式启动数据库。 PFILE：指定启动实例时使用的文本参数文件，filename为文件名。 实例启动时必须读取一个初始化参数文件以获取有关参数配置信息。 关闭数据库实例 Oracle关闭数据库实例过程：关闭数据库、卸载数据库、关闭实例。 关闭数据库语法格式：SHUTDOWN [NORMAL | TRANSACTIONAL | IMMEDIATE | ABORT]。 NORMAL：以正常方式关闭数据库。 对关闭数据库时间没有限制时，通常使用这种方式关闭。 阻止任何用户建立新连接；等待当前所有正在连接的用户主动断开连接；所有用户断开连接后立即关闭数据库。 TRANSACTIONAL：在当前所有的活动事务被提交完毕之后，关闭数据库。 阻止用户建立新连接和开始新事务；等待所有活动事务提交后，断开用户连接；所有事务提交完毕、所有用户断开连接后，关闭数据库。 IMMEDIATE：在尽可能短的时间内立即关闭数据库。 阻止用户建立新连接和开始新事务；将未提交的活动事务回退；关闭数据库。 ABORT：以终止方式关闭数据库，具有一定的强制性和破坏性，可能丢失数据信息，影响数据库的完整性。 阻止用户建立新连接和开始新事务；取消未提交的活动事务，不是回退；立即终止正在执行的任何SQL语句；立即关闭数据库。 </description>
    </item>
    
    <item>
      <title>MySQL基础</title>
      <link>https://supersonnya.github.io/operation/database/mysql/database-mysql/</link>
      <pubDate>Sun, 09 Aug 2020 14:10:02 +0800</pubDate>
      
      <guid>https://supersonnya.github.io/operation/database/mysql/database-mysql/</guid>
      <description>基本操作 操作表 SHOW CREATE TABLE 表名：查看指定表的创建语句 DESC 表名：查看表结构 ALTER TABLE 表名 MODIFY 列名 列类型：修改列类型 ALTER TABLE 表名 CHANGE 原列名 新列名 列类型：修改列名 ALTER TABLE 原表名 RENAME TO 新表名：修改表名称 删除表 TRUNCATE：先删除表和数据，再按照表结构重建表 DCL 一个项目创建一个用户，一个项目对应的数据库只有一个 用户只对这个数据库有权限 创建用户 CREATE USER 用户名@IP IDENTIFIED BY &amp;lsquo;PASSWORD&amp;rsquo; CREATE USER 用户名@&amp;rsquo;%&amp;rsquo; IDENTIFIED BY &amp;lsquo;PASSWORD&amp;rsquo; 查看权限 SHOW GRANTS FOR 用户名@IP 删除用户 DROP USER 用户名@IP 排序 ORDER BY：后面对多列排序，依次筛选，前面列相同时才进行后面的排序 聚合函数 COUNT() SUM() MAX() MIN() AVG() 分组 分组时查询的列除了主信息，只能是聚合函数，否则导致逻辑错误 WHERE 是分组前的筛选，HAVING 是分组后的筛选 LIMIT 方言 SELECT * FROM tableName LIMIT 4, 3;从第5行开始，查询三行 约束 约束是添加在列之上的，用来约束列 1.</description>
    </item>
    
  </channel>
</rss>
